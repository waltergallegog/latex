\chapter{Application Development} \label{chap:dev}

%\section{Requirements (and Specifications)}
%TODO
\todo{req and spec}


\section{Design}

The purpose of this section is to give the reader a clear overview of how the application works in general terms. 

A simplified design architecture is displayed in figure \ref{fig:BasicDesign}. It shows which software libraries are used by the application and when it uses them.


\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{chapters/figures/development/BasicDesign.pdf}
	\caption{Basic Design: Used Libraries}
	\label{fig:BasicDesign}
\end{figure}

The following is a brief explanation of how this libraries were usaee. More details about each Library and why they were chosen were given in section \ref{chap:lib} and section \ref{sec:imp} deals with the actual implementation.

\subsection{L0 and L1 Authentication libraries}

When the user starts any application based on the SEcube™ platform, the first steps to perform are to open the communication with the device using Level0 functions from both host and device, and to authenticate the user by checking the login pin, using Level1 functions (again, from both sides). Figure \ref{fig:BasicDesign} depicts how the SEcubeWallet uses the authentication functions and they in turn communicate with the SEcube™ chip.

\subsection{secureSQLite3}
As explained before, wallets are managed as SQLite DataBases, that need to be securely stored. Fortunately, the SEcube™ SDK already provides a Level2 API for creating and managing encrypted SQLite DBs, called secureSQLite3 (Available in the SEfile SDK\cite{SEcubeRes}). This API exploits the SEfile API to wrap some of the functions of the original SQLite3 library, avoiding OS calls.

secureSQLite allows to create/edit/save/open databases that when written to the disk are encrypted and can only be read when the SEcube™ is connected. Additionally, as it is implemented using wrappers, the developer only needs to include the source files in the project and can manage secureSQLite DB with the same functions used for regular SQLite DB.

Figure \ref{fig:BasicDesign} shows the SEcubeWallet application using secureSQLite to read/write the encrypted wallet stored in disk.

\subsection{SQLite3}
Because each call to the secureSQLite library involves a request to the SEcube™ device, in order to avoid an unnecessary high amount transmitted data, a regular SQLite3 DB is also used, but its unencrypted data is never saved to the disk. SQLite3 allows for the creation of an In-Memory DB, i.e. a DB whose content is always in the application's memory space and is therefore secured by the operating system. 

The In-memory DB is used for editing. When the user want to save the wallet, i.e. write it to the disk, the contents of the In-Memory DB are dumped to the encrypted secureSQLite DB. When the user opens a wallet from the disk, the reverse process occurs.

With the In-memory DB, the user experience is increased as the application is very responsive when editing, while a high level of security is maintained.

\subsection{Password Generator}
As the purpose of the application is to securely store passwords, said passwords should be as strong as possible. It does not make sense to protect a password that can be easily cracked by a hacker using brute force. That is why the application also includes a Password Generator.

PwGen \cite{pwgen} is an open source library that generates passwords, that can either be easy to remember, or completely random. Random passwords are more secure, but as the are difficult to remember, their use only makes sense when the user stores them in a wallet manager. Among other aspects, length and characters used (Numbers, Upper cases) can be configured too.

When the user is adding a new entry to a wallet, they can chose to enter a password or to automatically generate one.

\subsection{PassPhrase Generator}
In addition to the Password Generator PwGen, the user has the possibility to generate PassPhrases instead. PassPhrases are a popular alternative because they are easier to memorize and therefore can be longer, which in turns make them more secure. Further details about the usefulness of PassPhrases and how they compare against regular Passwords were given in section \ref{sec:zxcvbnth}.

Although the PassPhrase Generator is not a library per se, it was included in the diagram because of its close relation with the PwGen and zxcvbn \cite{zxgit} libraries. It was developed by the author, and it works by selecting random words out of dictionary files. 

The user can configure how many words each passphrase must have, the minimum length of said words, and which dictionary files to use, among other options.

\subsection{Strength Estimator}
To give the users feedback on how good the password they are about to store is, the application uses the open source project zxcvbn to give an estimation of the passwords entropy, and how long it would take for a hacker to break it. zxcvbn evaluates if the password is a common word, or a combination of them, a last name, a date, or letters close to each other in a keyboard (thus the name zxcvbn). With the estimator users are encouraged to create good passwords that are not necessarily completely random and difficult to remember, or annoying to type.


\section{Implementation} \label{sec:imp}

To recap what has been explained in previous sections, these are the key aspects of the used libraries:

\begin{itemize}
\setlength\itemsep{0pt}

\item To start the connection with the SEcube™, the Level0 library is used
\item To authenticate the user, by checking if the entered login pin is the same as the pin stored in the SEcube™, the Level1 library is used.
\item A SQLite in-memory database is used for editing the wallet.
\item A secureSQLite encrypted data base is used for storing the wallet in disk.
\item The application includes a password and a passphrase generator with several configuration options.
\item The application also includes an strength estimator, so the user has an idea of how good their passwords are.

\end{itemize}

In the following sections each of the elements and functionalities of the application will be explained, how they were implemented, some interesting pieces of code and examples of use.

\subsection{User authentication} \label{sec:authen}

When the user starts the application, the first window to appear is the Login Dialogue, shown in figure \ref{fig:logina}. In it the user is asked to enter the login pin and by clicking accept the Challenge-Based Authentication process between the SEcubeWallet application and the SEcube™ chip starts. If the authentication fails because the entered pin is wrong, the message in \ref{fig:loginb} is shown. If it fails because there was already an opened session, the confirmation dialogue shown in \ref{fig:loginc} appears. If the authentication is completed successfully the user is granted access to the main window.

\begin{figure}[ht]
  \centering
  \subfloat[Login Dialogue\label{fig:logina}]
  {\includegraphics[width=0.3\linewidth]{chapters/figures/development/login.png}}
  {}
  \subfloat[Wrong Password\label{fig:loginb}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginWrong.png}}
  {}
  \subfloat[Already an open session\label{fig:loginc}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginOpen.png}}
  \caption{Login Dialogue and possible outcomes}
 \label{fig:login}
\end{figure}

The authentication process begins with the discovery of SEcube™ devices connected to the PC. This is achieved using Level0 APIs as seen in the listing \ref{lis:dis}. Each discovered device is added to the \texttt{QComboBox} displayed in the login dialogue and to a \texttt{QList}.

\begin{lstlisting}[style=customc, float=htb, caption={Connected Devices discovery}, label = {lis:dis}]
//// *** variables declaration ***
se3_disco_it it;
QList<se3_disco_it> device_found;
QComboBox* chooseDevice;
bool found = true;

//*** Refresh button slot *****
L0_discover_init(&it); //initialize iterator
while((found = L0_discover_next(&it))){ //move to next device
  chooseDevice->addItem(QString::fromLocal8Bit(
    it.device_info.path, -1)); //add to GUI
  device_found.push_back(it); //add to QList
}
\end{lstlisting}

The user then selects one of the discovered devices using the \texttt{QComboBox}, enters their login pin and clicks accept. This triggers the listing \ref{lis:login}. The first step is to open the device communication using the Level0 function \texttt{L0\_open}. Then \texttt{L1\_login} starts the actual challenged based authentication using the login pin entered by the user. Using this type of authentication ensures the login pin is never communicated between the devices and stolen with a physical attack on the USB cable. Rather, a random number is generated in the host and transmitted to the device. The login pin is then used in both the host and the device to encrypt this random number using a \texttt{pbkdf2} function. The resulting key on the device is sent to the host, who compares it with its own key. If they are the same it means the login pin entered by the user is equal to the login pin stored in the device, and the only information transmitted are random numbers that an attacker cannot understand. (The actual authentication procedure implemented is a little bit more complex, but is based on the same idea described here).
%TODO
\todo{explain better the challenge based}

\begin{lstlisting}[style=customc, float=htb, caption={Open device and try to login}, label = {lis:login}]
// *** variables declaration ***
//use selected index at QComboBox to retrieve 'it' from QList.
int device_index = chooseDevice->currentIndex();
se3_disco_it it = device_found.at(device_index);

se3_session s; 
se3_device dev;
int ret;
bool logout = false; //if true, L1_login logs out first

//*** Accept button slot *****
if(!dev.opened) // open communication with device
  if((L0_open(&dev, &(it.device_info), SE3_TIMEOUT))!= SE3_OK)
    exit(1); //error

ret = L1_login(&s, &dev, pin, SE3_ACCESS_USER, logout); //login

if (ret != SE3_OK){    //error at login
  if (ret == SE3_ERR_PIN) //The password is wrong
    show_wrong_pass_messsage;
    
  else if (ret == SE3_ERR_OPENED){
    // there is already an opened session, ask user if he wants to close it
    if(confirmation_dialog_reply == Yes){ 
      logout = true; 
      call_this_function_again;
      //next time L1_login will close the existing session
    }
  }else            
    exit(1);//other error
}else
  accept();//All ok, go to main window
\end{lstlisting}

After both device and host have the same key, it is used to encrypt the communication channel. A token is generated in the device and transmitted on the encrypted channel to the host. This token is a random number, and is used from that point on to validate any communication between host and device. The SEcube™ Chip does not accept any command from the host if the token it sends is not the correct one. The only command accepted without a token is off course, login. In the logout procedure, this token is cleared (set to zeros), so a login later on is possible.

One problem found during the development of the application is the following: If after login in, the SEcubeWallet application crashes, the logout command, that is usually issued when closing, is never executed, and the device remains with an active token value. Therefore, when the user launches the application again, the login will fail, because the device expects a token value from the host. To solve this issue a few options were considered:

\begin{itemize}
\setlength\itemsep{-3pt}

\item Make sure the application never crashes. Because software applications are rarely completely bug-free, and even if they are, an external problem like a bug in the OS can make them crash, this option is not feasible. 
\item Make sure the logout command is issued even in the case the application crashes. This option sounded promising, and a two-process idea was even developed. Process 1 is only in charge of calling Process 2, in which the actual application was executed. if Process 2 crashes, Process 1 remains alive and performs the logout procedure. To make this work, shared memory was used to communicate the session variable (were the token is stored), so both processes could send commands to the device. The idea was latter on dropped because of two main reasons: First of all, it did not solve the case were the problem is external (OS bug), secondly, it was too complicated because of the sharing memory mechanism (The session variable is a fairly complex structure, with a lot of pointers), and because the token was being shared by two processes, this could open another possibility of attacks.
\item As the two previous ideas failed, it was decided that a small modification to the login behaviour on the SEcube™ firmware was necessary. The modification consist on letting the login function clear the token field if necessary. This does not compromise the security of the system because access to the chip is only granted if the login pin entered by the user is the right one. One concern that may rise is that, while an application is using the SEcube™, another one could close the session by issuing a Login command, but this is not possible because the \texttt{L0\_open} function only allows one process to communicate with the chip at a time, using a file locker in the .se3magic
file saved in the SEcube™ SDcard.
\end{itemize} 

The new behaviour is implemented in listings \ref{lis:se3cmd1}.
If after a crash the session in the SEcube™ remains open, and the host tries to login again, the SEcube™ returns the new error code \texttt{SE3\_ERR\_OPENED}. The host then can decide if it wants to force the SEcube™ to close the opened session so it can login, with the new command \texttt{SE3\_CMD1\_LOGOUT\_FORCED}, which forces a logout without checking the token. After this command the host can login as usual. This steps are included in the host side \texttt{L1\_login} function, which now has an additional parameter to control whether to force a logout or not. This parameter is the one used in listings \ref{lis:login}, set to true when the user clicks \textsc{yes} in the confirmation dialogue asking whether or not to close the previous session.

\begin{lstlisting}[style=customc, float=htb, caption={Modification in SEcubeFirmware, file se3\_cmd1.c}, label = {lis:se3cmd1}]
if (se3c1.login.y) { // if there is already an opened session
  if (memcmp(se3c1.login.token, req_params.token, SE3_L1_TOKEN_SIZE)) { //and token mismatch
    if (req_params.cmd==SE3_CMD1_CHALLENGE)//someone (maybe same user after a crash) trying to login.
      return SE3_ERR_OPENED;//notify host there is already an opened session, if host wants to continue, it will call SE3_CMD1_LOGOUT_FORCED
    else if (req_params.cmd==SE3_CMD1_LOGOUT_FORCED)//if the user agreed to close the existing session by forcing a logout
      req_params.cmd=SE3_CMD1_LOGOUT;//call logout as usual  
    else
      return SE3_ERR_ACCESS;
  }
}
\end{lstlisting}




\subsection{Main Window}

The SEcubeWallet GUI's main window developed using Qt is shown in figure \ref{fig:mainWindow}.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=1\columnwidth]{chapters/figures/development/mainWindow.png}}
  \caption{SEcubeWallet main window}
  \label{fig:mainWindow}
\end{figure}

The main window is composed of the following elements:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Table View:} Used for displaying the wallet entries. It resizes smoothly with the window, can be ordered by any of the columns, and the passwords are hidden by default but can be shown if the user wants to.
\item \textbf{Filters:} The user can search in each of the table's columns using filters. These filters are implemented inside a separate container, but they resize together with the table.
\item \textbf{Entries Tool Bar:} It is positioned to the left of the table. It has the actions: add/edit/delete entries, show passwords, fit table, change date filter, launch domain and select table.
\item \textbf{Tables Tool Bar:} It is positioned to the top right of the table. It has the actions: add/rename/delete table.
\item \textbf{Wallets Tool Bar:} It is positioned to the top left of the table. It has the actions: new/open/delete/save/save as/close Wallet. 
All of the above Tool Bars are movable.
\item \textbf{Menu Bar:} It is positioned at the top of the window. It contains all the previous actions, plus preferences and help.
\item \textbf{Status Bar:} Positioned at the bottom of the window, it is used to display some success/error messages to the user and the current wallet name.
\end{itemize}

\subsection{Wallet actions}

The actions regarding wallets: New, Save, Save As, Open, Close and Delete are explained in detail in the following.

\subsubsection*{New Wallet action}

When the user triggers the the \texttt{New\_Wallet} action, the first step to execute is to check if there is another wallet opened and if it has unsaved changes. If, so the confirmation dialogue in figure \ref{fig:confSave} is shown, so the user can decide whether to save the changes, discard them, or cancel the creation of a new wallet.
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.6\columnwidth]{chapters/figures/development/confSave.png}}
  \caption{Save Confirmation dialogue}
  \label{fig:confSave}
\end{figure}

In case the user clicks \texttt{Save}, the \texttt{Save\_Wallet} action is triggered before continuing. \texttt{Discard} continues without saving, and \texttt{Cancel} returns without doing anything.

If the process continues, the next step is to close any previous in-memory database handlers, save the \texttt{table\_view} geometry (if any), and open a new in-memory database using the Qt class \texttt{QSqlDatabase}, as seen in listings \ref{lis:newDB}.

\begin{lstlisting}[style=customc, float=htb, caption={New in memory database}, label = {lis:newDB}]
QSqlDatabase dbMem; //The database handler, declared in header 

//Check if SQLite is installed on OS
if(!(QSqlDatabase::isDriverAvailable("QSQLITE")))
  exit (1); //the application does not work without SQLite

if (dbMem.isOpen()){ 
  save_table_geometry;
  dbMem.close();//close any prev. opened database
}

dbMem = QSqlDatabase::addDatabase("QSQLITE");
dbMem.setDatabaseName(":memory:"); // in-memory database
if(!dbMem.open()){
  return;//Error opening, do nothing
}
\end{lstlisting}

As explained before the in-memory data base is used for editing. It has the advantage of being fast because there is no access to the hard disk, and secure, because all the data is in the application memory space, and therefore is protected by the OS.

The last step is to update the GUI state, by enabling some action like \texttt{Add\_Table} and \texttt{Save\_Wallet}, and disabling others, like \texttt{Delete\_Table} and \texttt{Rename\_Table}.

\subsubsection*{Save Wallet action} \label{sec:savewalletaction}
To write the wallet contents to the disk, it is necessary to have a filename, so the first step is to check if the user already entered one (from previous saves). If not, with the dialogues in figure \ref{fig:saveWallet} the user can choose the directory and the filename to save.

\begin{figure}[ht]
  \centering
  \subfloat[User can enter a New name. Current wallets are displayed\label{fig:saveWalleta}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/saveWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Save Wallet dialogues}
 \label{fig:saveWallet}
\end{figure}

The need for two dialogues instead of a regular file browser comes from the fact that the chosen filename will not be readable from the OS, since \texttt{SEfile} also encrypts it. Similarly, wallets already saved in the directory cannot be displayed with a regular file browser, so it is necessary to use the \texttt{SEfile} function \texttt{secure\_ls} and display its output in the list seen in figure \ref{fig:saveWalleta}. The declaration of this function is in listings \ref{lis:securels}. To chose the working directory, it is enough to use the \texttt{QFileDialog} class. If the user wishes they chose an existing filename and can overwrite the correspondent wallet.

\begin{lstlisting}[style=customc, float=htb, caption={secure\_ls declaration}, label = {lis:securels}]
 /* This function identifies which encrypted files and encrypted directories are present in the directory pointed by path and writes them in list. It only recognizes the ones encrypted with the current environmental parameters.*/
 
uint16_t secure_ls(    //returns 0 in case of success
  char *path,          //[in]Path to the directory to browse
  char *list,          //[out]Allocated array to store filenames
  uint32_t *list_length//[out]Num of char written in list
);
\end{lstlisting}


After having a filename the next step is to read all of the tables in the current in-memory database, row by row. For each row a \texttt{SQLite} statement of the form \texttt{INSERT INTO table VALUES(user, dom, pass, date, desc)} is created. All of them are merge into a single statement which is executed into the secured in-disk database. This ensures only one access to the SEcube™ and disk. This process is somewhat slow and the GUI is disabled while it is performed. A simplified version of the code is shown in listing \ref{lis:save} 

\begin{lstlisting}[style=customc, float=htb, caption={simplified Save process}, label = {lis:save}, escapechar=¬]
sqlite3 *dbSec;    //Secure database declaration, in header
QSqlDatabase dbMem;//The database handler, declared in header 
QSqlQuery query;   //To exec SQLite statements, dec. in header

//Create SQLite DB, with filename specified by user If SEcube is connected, the resulting file is encry.
sqlite3_open_v2 (fileName.toUtf8(),   
                &dbSec, 
                SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE , 
                NULL) 
                
QString finalSql; //To Merge all the SQLite statements.
static const QString insert = 
  QStringLiteral("INSERT INTO '%1' VALUES(%2);"); //statement
  
dbMem.tables(QSql::Tables); //list of the tables in in-memory DB
tables.prepend("NoEmpty");  //Workaround: prepend Empty table   ¬\label{line:empty}¬
foreach (const QString table, tables) { // loop all the tables
   QString sql= "create table '"+table+//Create table statement 
                "'(id integer primary key, "
                "Username TEXT, "
                "Domain TEXT, "
                "Password TEXT, "
                "Date TEXT, "
                "Description TEXT );" ; 
  sqlite3_exec(dbSec, sql.toUtf8(), NULL, 0, &zErrMsg);// exec
  
  if (table=="NoEmpty"){//just an empty table
    set_values_to_empty;
    finalSql += insert.arg(table).arg(values.join(", "));
  }else{
    query.prepare(QString("SELECT * FROM [%1]").arg(table));
    query.exec()
    while (query.next()){ //row by row
      values = query_read_row();
      finalSql += insert.arg(table).arg(values.join(", "));
    }
}
//single write into secure database, fill the tables
sqlite3_exec(dbSec, finalSql.toUtf8(), NULL, 0, &zErrMsg);
\end{lstlisting}

One problem found during the open process of a secured in-disk wallet is that the first table is always corrupt and gives the error: \texttt{database disk image is malformed}. The error only occurs when using the SEcube™ version of the SQLite library. Because it was impossible to find the origin of the error, it was decided to use a workaround: In the save wallet process, an empty table is inserted at the beginning of the in disk database (see line \ref{line:empty} in listings \ref{lis:save}). When opening the wallets, the empty table is simply ignored. With this, the real tables are always correctly read an the application works as intended.


\subsubsection*{Save Wallet As action}

This action is very simple, it just clears the current filename (if any), and calls the \texttt{Save\_Wallet} action; as there is no filename, the user is forced to enter a new one. The only point to be careful about is that, in case the \texttt{Save\_Wallet\_As} process is aborted, the previous filename needs to be recovered, so before clearing, the filename is temporary stored in case it is needed.

\subsubsection*{Open Wallet action}
Similarly to the \texttt{New\_Wallet} action, the first step is to check for unsaved changes and ask the user if save them, discard them or cancel, with the dialogue in figure \ref{fig:confSave}

If the user decides to continue, the dialogues in figure \ref{fig:openWallet} allow them to choose from the list the wallet to open.

\begin{figure}[ht]
  \centering
  \subfloat[User chooses the wallet to open from the list]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/openWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Open Wallet dialogues}
 \label{fig:openWallet}
\end{figure}

The application proceeds doing the inverse process to the \texttt{Save\_action}, that is, read all the tables from the secure in-disk database and create an in-memory database with this data. To do so, the listings in \ref{lis:openWallet} is used. First, the in-disk data base is opened as read only, and a list named \texttt{tables} with the existent tables in it is generated. Then an in-memory database is created. Finally, for each table in \texttt{tables}, its contents are read, a correspondent table is created in the in-memory database, and the later is populated with the read contents from the in-disk DB.
\begin{lstlisting}[style=customc, float=htb, caption={Simplified Open Wallet action}, label = {lis:openWallet}]
sqlite3_open_v2(fileName.toUtf8(),
                &dbSec, 
                SQLITE_OPEN_READONLY, NULL)); //open in-disk DB

QString tableNames="SELECT name FROM sqlite_master "
                    "WHERE type='table' "
                    "ORDER BY name;";
sqlite3_exec(
  dbSec, tableNames.toUtf8(), 
  callback_createTableList,//builds the 'tables' list 
  this, &zErrMsg);

if (dbMem.isOpen()){ 
  save_table_geometry;
  dbMem.close();//close any prev. opened database
}
dbMem = QSqlDatabase::addDatabase("QSQLITE");
dbMem.setDatabaseName(":memory:");
dbMem.open();
query = QSqlQuery(dbMem);

foreach (const QString table, tables){
  QString sql = "create table '"+table+
                "'(id integer primary key, "
                "Username TEXT, "
                "Domain TEXT, "
                "Password TEXT, "
                "Date TEXT, "
                "Description TEXT );";
  if (table!="NoEmpty"){ //Workaround: ignore empty
    query.prepare(sql);
    query.exec(); //create table in in-mem DB
  }
  QString SqlStatement = 
    QStringLiteral("SELECT * FROM '%1';").arg(table);
  sqlite3_exec(
    dbSec, SqlStatement.toUtf8(), 
    callback_populateTable, //populates in-mem DB
    this, &zErrMsg);
}
\end{lstlisting}


The \texttt{SELECT FROM} statements in \texttt{sqlite3} require the use of a \textsl{callback} function, which is called for every result row, and receive the actual data from the data base as an \texttt{argv[]} argument. In the open process two of these functions are needed, shown in listing \ref{lis:callback}. 
In \texttt{create\_TableList}, the list \texttt{tables} is build by simply reading the only element in the \texttt{argv[]} array, as each row only consists of a table's name. 
In \texttt{populatetable}, the table in the in-memory DB is populated, row by row with each call.  In this case the \texttt{argv[]} array holds the values in a single row coming from the in-disk DB.

Finally the GUI is updated, by enabling some elements and disabling others.

\begin{lstlisting}[style=customc, float=htb, caption={Callback functions for Sqlite3 SELECT}, label = {lis:callback}]
//Build TableList from in-disk DB
callback_createTableList(int argc, char**argv, char**azColName){ 
  tables << argv[0]; //only one arg, the table name
  return 0;
}
//fill 'table' in in-mem DB with data from in-disk DB
callback_populateTable(int argc, char **argv, char **azColName){ 
  if (table=="NoEmpty") // we dont want NoEmpty in the in-mem db
    return 0;
  int i;  

  static const QString insert = 
    QStringLiteral("INSERT INTO '%1' VALUES (%2);");
  
  QStringList values;
  QString aux;
  for(i = 0; i<argc; i++){//argv holds values from a single row 
      aux = argv[i];
      values << "'"+aux+"'"; 
  }
  query.prepare(insert.arg(table).arg(values.join(", ")) );
  query.exec();
  return 0;
}
\end{lstlisting}


\subsubsection*{Close Wallet action}

This action is very simple. As usual, before closing the current wallet a check for unsaved changes is performed, and the user is asked what to do with them using a confirmation dialogue. If the user decides to continue, the in-memory database handler is closed, and the table geometries are saved. Finally the GUI is updated.

\subsubsection*{Delete Wallet action}

Deleting a wallet involves deleting an in-memory database and/or an in-disk database. 

If only the in-memory database exists (user has not save it to disk yet), the wallet is simply closed, as in the previous section.

If there is no opened wallet, and the user wishes to delete an in-disk database, a select file dialogue equal to the one in the \texttt{Open\_Wallet} action is shown, where the user can chose the wallet to delete. Then the wallet is deleted as shown in listing \ref{lis:delete}. First we obtain the encrypted version of the filename, using the SEcube™ API, and then the file in the disk is deleted using standard OS calls. 

\begin{lstlisting}[style=customc, float=htb, caption={Delete an in-disk database}, label = {lis:delete}]
crypto_filename(fileName.toUtf8().data(), 
                enc_filename, &enc_len 
                );
QFile::remove(enc_filename); //OS call
\end{lstlisting}

If both in-disk and in-memory wallets are to be deleted, that is, if there is an opened wallet that has been already saved to disk, there is no need for a select file dialogue, as the filename is known from the \texttt{Save\_Wallet} process. The in-memory database handler is closed and the in-disk encrypted wallet file deleted as explained above. 

In all the above cases, a confirmation dialogue ask the user if they are sure about deleting the wallet.

\subsection{Table actions and display}
Actions and classes regarding tables, they creation and display, are explained in the following sections: 

\subsubsection*{Add Table action}

With an in-memory wallet opened, the user can add a new table to it by simply entering a name. the listing \ref{lis:addTable} shows this process. With the \texttt{QIntputDialog} class, it is possible to ask the user for a name easily. If the name is valid, the sqlite query to add the table is executed. It may be the case the table already exists, in which case the query execution returns an error and the user is notified.

\begin{lstlisting}[style=customc, float=htb, caption={Add a New Table}, label = {lis:addTable}]
bool ok;
QString tableName = QInputDialog::getText
  (this, "New Table",
  "Enter new table name",
  QLineEdit::Normal,"", &ok);

if (!ok || tableName.isEmpty())
  return;

QSqlQuery query(dbMem);
query.prepare("create table '"+tableName+
              "'(id integer primary key, "
              "Username TEXT, "
              "Domain TEXT, "
              "Password TEXT, "
              "Date TEXT, "
              "Description TEXT )");

if (!query.exec()){
  return; // maybe a table with that name already exists, or is a reserved SQLite command
\end{lstlisting}

If the table is the first one to be added in the wallet, a \texttt{table view} and \texttt{filters} are created and added to the GUI, in order to display the table. Otherwise, the \texttt{table view} is just updated. These elements are explained in details in the upcoming sections.

\subsubsection*{Delete Table action}

To delete a table it is enough to use the SQLite \texttt{DROP TABLE} command as seen in listings \ref{lis:deleteT}. With the \texttt{QMessageBox} the user is asked to confirm before deleting.

After deleting, the \texttt{table view} needs to be updated, to show the next table in the wallet. If there are no more tables, the view is simply hidden, and other GUI elements like \texttt{Add Entry} disabled.

\begin{lstlisting}[style=customc, float=htb, caption={Delete Table}, label = {lis:deleteT}]
reply = QMessageBox::question
          (this,
          "Delete",
          "Are you sure you want to delete Table "+tableName,
          QMessageBox::Yes|QMessageBox::No);
if (reply == QMessageBox::No)
  return;

QSqlQuery query(dbMem);
query.prepare("DROP TABLE '" + tableName+"'");
\end{lstlisting}

\subsubsection*{Rename Table action}
To Rename a table the SQLite command \texttt{ALTER TABLE RENAME TO} is used as seen in listing \ref{lis:renameT}. After this, the \texttt{QComboBox} used to select the current table being displayed is updated to reflect the name change.
\begin{lstlisting}[style=customc, float=htb, caption={Rename Table}, label = {lis:renameT}]
QSqlQuery query(dbMem);
query.prepare("ALTER TABLE '" + currentName + "' RENAME TO '"+newName+"'");
query.exec();
\end{lstlisting}

\subsubsection*{Select Table}

To allow the user to select one table to display out of the existent ones in the current Wallet, a \texttt{QComboBox} is added to the Entries Tool Bar. Each time a Wallet is opened/closed, or a table is added/renamed/deleted, the items in the QComboBox are updated accordingly. When the selected item in the QComboBox changes, the tableView update procedure explained in the following section is triggered.

\subsubsection*{Table display}
To display the entries in each of the Wallet tables, a \textbf{Model/View} architecture was followed. From the official Qt documentation \cite{modelview}:
 
``Model-View-Controller (MVC) is a design pattern originating from Smalltalk that is often used when building user interfaces. In Design Patterns, Gamma et al. write:

MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.

If the view and the controller objects are combined, the result is the \textbf{model/view} architecture. This still separates the way that data is stored from the way that it is presented to the user, but provides a simpler framework based on the same principles.''

``The model communicates with a source of data, providing an interface for the other components in the architecture. The nature of the communication depends on the type of data source, and the way the model is implemented.

The view obtains model indexes from the model; these are references to items of data. By supplying model indexes to the model, the view can retrieve items of data from the data source.

In standard views, a delegate renders the items of data. When an item is edited, the delegate communicates with the model directly using model indexes.''

Figure \ref{fig:modelview} (taken from the Qt documentation), shows the way these three elements interact between them and with the data. 

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.5\columnwidth]{chapters/figures/development/modelview.png}}
  \caption{The Qt Model View Architecture}
  \label{fig:modelview}
\end{figure}

\begin{lstlisting}[style=customc, float=htb, caption={Model/View architecture implementation}, label = {lis:modelview}]
// Create and configure model to access data in table
model = new QSqlTableModel;
model->setTable(tableName);
model->select();//update the model selection
model->setEditStrategy(QSqlTableModel::OnManualSubmit);
  //Changes will be updated manually by calling submitAll()

//Create ProxyModel for filtering
proxyModel = new MySortFilterProxyModel(this);
proxyModel->setSourceModel(model); //connect proxyModel to Model

//Create and connect delegate to hide passwords
passDelegate=new PasswordItemDelegate(this);
ui->tableView->setItemDelegateForColumn(PASS_COL, passDelegate);

//Connect to table view, resulting in: 
//Sql <--> Model <--> ProxyModel <--> Delegate <--> TableView
ui->tableView->setModel(proxyModel);

//Configure table
ui->tableView->//Hide SQLite ID column, not useful to user
  setColumnHidden(IDENT_COL, true);
ui->tableView->//Hide row header, not useful
  verticalHeader()->hide();
ui->tableView->//To make the table view not editable
  setEditTriggers(QAbstractItemView::NoEditTriggers);
ui->tableView->//To allow only one row  selection.
  setSelectionBehavior(QAbstractItemView::SelectItems);
ui->tableView->//So we can edit one entry per time
  setSelectionMode(QAbstractItemView::SingleSelection);

ui->tableView->show();// show table
\end{lstlisting}

In the SEcubeWallet application these elements correspond to:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Data:} The data coming from the database. As we are displaying only one table at a time, the data actually corresponds to a single table.
\item \textbf{Model}: \texttt{QSqlTableModel}, a Qt class which provides an editable data model for a single database table.
\item \textbf{Proxy Model}: \texttt{MySortFilterProxyModel}, a class written by the author inheriting from the Qt \texttt{QSortFilterProxyModel} class. It implements custom filtering for each of the columns, in particular for the date.
\item \textbf{View}: \texttt{MyQTableView}, a class written by the author inheriting from the Qt \texttt{QTableView} class. \texttt{MyQTableView} reimplements the \texttt{resizeEvent} to make sure the user has the best GUI experience. This new class allows for manual resizing of each column as well as automatic resizing when the widow size changes. Also, there is a button that allows the user to fit the table in the available space by giving all the columns the same width.
\item \textbf{Delegate}: \texttt{PasswordItemDelegate}, a class written by the author inheriting from the Qt \texttt{QStyledItemDelegate} class. It is used to implement the show/hide password functionality.
\end{itemize}

There is one element not mentioned in the model/View architecture: the \textbf{Proxy Model}. It will be explained in details in the filters section. The \textbf{delegate} will be explained in the Show Password section.

In listing \ref{lis:modelview} the model view architecture is implemented. Model, Proxy Model and Delegate are interconnected among them, with the database table and with the GUI's table view. Additionally some display tweaks are made, for instance the ID column, vertical header and passwords are hidden.



When it is necessary to change the table to be displayed, either because the user changes walllet or table, or deletes one, the listing \ref{lis:updatemv} is used. Only the \textbf{model} needs to be updated, because it is the one connected to the data. The table view geometry needs to be saved and restored, because with the data change, the columns are automatically resized by Qt to fit the new data, which is visually annoying for the user.

\begin{lstlisting}[style=customc, float=htb, caption={update the model/view}, label = {lis:updatemv}]
save_table_geometry;//each column width
model->setTable(tableName);
model->select();
    
restore_table_geometry;
ui->tableView->setColumnHidden(IDENT_COL, true);//required
\end{lstlisting}

\subsubsection*{Show Passwords action}

To show the passwords it is enough to \textsc{not} use a delegate for the correspondent column. Conversely, to hide them again, the delegate is used, as seen in listing \ref{lis:pass}. The delegate \texttt{displayText} method definition is also shown. Its job is to return the bullet character eight times instead of the actual item value.

\begin{lstlisting}[style=customc, float=htb, caption={Show/Hide Passwords}, label = {lis:pass}]
// *** in pasworditemdelegate.cpp ***
PasswordItemDelegate::PasswordItemDelegte(QObject* parent): QStyledItemDelegate(parent){}
//inherits from QStyledItemDelegate

QString PasswordItemDelegate::displayText
  (const QVariant &value, const QLocale &locale) const {
    return (QString("%1").arg(QChar(0x2022)).repeated(8));
} // just returns the bullet character 8 times

// *** in mainwindow.cpp ***
void MainWindow::on_action_Show_Passwords_toggled(bool show){

	passDelegate=new PasswordItemDelegate(this);
	if (!show)//do not show passwords: use passDelegate
	  ui->tableView->setItemDelegatForColumn(
	    PASS_COL, passDelegate);
	 
	else{ //show passwords: do not use delegate
	  QMessageBox::StandardButton reply;
	  reply = QMessageBox::question(
	            this,
	            "Passwords",
	            "Are you sure you want to show your passwords",
	            QMessageBox::Yes|QMessageBox::No);
	  if (reply == QMessageBox::No)
	    return;//if error or cancel, do nothing
	
	  ui->tableView->setItemDelegateForColumn(PASS_COL, 0);
	}
}
\end{lstlisting}

\subsubsection*{Filters}
The filters implementation comprise two classes. The first one is related to the GUI, and its job is to align each of the filters with its corresponding table column. The second class is related to the data filtering per se.

The \textbf{filters alignment} is based on the \texttt{ColumnAlignedLayout} class by sashoalm \cite{aligned}. This class is a Layout that inherits from the \texttt{QHBoxLayout} Qt class. It reimplements the \texttt{setGeometry} method to reposition each of the elements in the layout to follow the correspondent column in the tableView that is being tracked. This implementation allows to add any type of widget to the layout, as long as the number of widgets equals the number of tracked columns. The class definition is shown in listing \ref{lis:aligned}.

\begin{lstlisting}[style=customc, float=htb, caption={Aligned Filters definition}, label = {lis:aligned}]
// *** filtersaligned.cpp ***
FiltersAligned::FiltersAligned(QWidget *parent) //constructor
: QHBoxLayout(parent){//inherits from horizontal Box Layout
  add_filters_to_layout; //add filters (most of them QLineEdits)
}
void FiltersAligned::setTableColumnsToTrack(QHeaderView *view) {
    headerView = view; //set tracked tableView
}
void FiltersAligned::setGeometry(const QRect &r){
  QHBoxLayout::setGeometry(r);

  int widgetX = parentWidget()->mapToGlobal(QPoint(0, 0)).x();
  int headerX = headerView->mapToGlobal(QPoint(0, 0)).x();
  int delta = headerX - widgetX;

  // repositioning
  for (int ii = 0; ii < headerView->count(); ++ii) {
    int pos = headerView->sectionViewportPosition(ii);
    int size = headerView->sectionSize(ii);
    auto item = itemAt(ii);
    auto r = item->geometry();
    r.setLeft(pos + delta);
    r.setWidth(size);
    item->setGeometry(r);
  }
}
\end{lstlisting}

To connect the aligned layout to the table view, the listing \ref{lis:alignedcon} is used. In it, an aligned filter object is created and is set as the Layout of a widget positioned over the tableView in the GUI. Then the aligned filter is set to track the tableView's \texttt{horizontalHeader}. Finally any geometry change in the \texttt{horizontalHeader}, or in the \texttt{horizontalScrollBar} calls the \textsc{slot} \texttt{invalidateAlignedLayout}, which in turns calls the \texttt{invalidate} method. This method resets the Layout's cached information, which forces a call to \texttt{setGeometry}. This ensures any resizing of the table's columns is reflected in the filters position.


\begin{lstlisting}[style=customc, float=htb, caption={Table View and aligned filters connection}, label = {lis:alignedcon}]
// *** in mainwindow.cpp when the tableView is created:
  filters = new FiltersAligned();
  ui->filtersWidget->setLayout(filters);
  filters->setTableColumnsToTrack(
    ui->tableView->horizontalHeader());
  filters->setParent(ui->filtersWidget);
  
  connect(ui->tableView->horizontalHeader(),
          SIGNAL(sectionResized(int,int,int)), 
          SLOT(invalidateAlignedLayout()));
  connect(ui->tableView->horizontalScrollBar(), 
          SIGNAL(valueChanged(int)),
          SLOT(invalidateAlignedLayout()));

//the SLOT
void MainWindow::invalidateAlignedLayout(){
    filters->invalidate(); 
}//clears the cache, which forces a call to setGeometry
\end{lstlisting}


The \textbf{data filtering} is done using a custom \texttt{SortFilterProxyModel}. For all the columns except the date, a simple case insensitive match is enough. For the date, using a button in the GUI, the user can choose among two options:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Exact Match filter: }In this configuration, the user enters the exact date they are looking for, using a \texttt{QDateEdit} input element.
\item \textbf{Older Than filter: }Because this is a password wallet, looking for an exact date may not be very useful. Instead, knowing which passwords are older than a given amount of time, and have therefore expired is more helpful. For instance the user could be interested in updating their passwords each six months, so with this filter they can show only those passwords that need to be changed. In figure \ref{fig:filterdate} an Older Than six months filter is shown (as of July the 13th 2018).
\end{itemize}

\begin{figure}[ht]
  \centering
  \subfloat[No filter]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/filterdatea.png}}
  {}
  \subfloat[Older Than 6 Months]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/filterdateb.png}}
  \caption{Date Older Than filter }
 \label{fig:filterdate}
\end{figure}

The filters implementation is very simple. It involves the reimplementation of the \texttt{filterAcceptsRow} method in the ProxyModel as in listings \ref{lis:filterReg}. This method  is called each time the user changes one of the filters contents. The filters work concurrently, so the user can search in multiple columns at the same time. All of them except the date one accept \texttt{RegExp}, so a search like \texttt{google|gmail} is possible. The password filter is only enabled when the passwords are visible.


\begin{lstlisting}[style=customc, float=htb, caption={Filters implementation}, label = {lis:filterReg}]
bool MySortFilterProxyModel::filterAcceptsRow
(int sourceRow, const QModelIndex &sourceParent) const
{
  QModelIndex userIndex = 
    sourceModel()->index(sourceRow, USER_COL, sourceParent);
  QModelIndex domainIndex = 
    sourceModel()->index(sourceRow, DOM_COL, sourceParent);
  QModelIndex passIndex = 
    sourceModel()->index(sourceRow, PASS_COL, sourceParent);
  QModelIndex descIndex = 
    sourceModel()->index(sourceRow, DESC_COL, sourceParent);

  QModelIndex dateIndex = 
    sourceModel()->index(sourceRow, DATE_COL, sourceParent);
  QDate thisDate = QDate::fromString(
    sourceModel()->data(dateIndex).toString(),format);

  return (//only return rows where the conditions are met    
    sourceModel()->
      data(userIndex).toString().contains(userRegExp)         && 
    sourceModel()->
      data(domainIndex).toString().contains(domainRegExp)     && 
    sourceModel()->
      data(passIndex).toString().contains(passRegExp)         &&
    sourceModel()->
      data(descIndex).toString().contains(descRegExp)         &&
    (thisDate<=filterDate_older||!filterDate_older.isValid()) &&
    (thisDate==filterDate_exact||!filterDate_exact.isValid()) &&
  );
}
\end{lstlisting}

\subsection{Entries actions}

In this section, the implementation of the actions add/edit/delete entry are explained.

\subsubsection*{Add Entry action}

The \texttt{AddEntry} class allows users to input a new entry to one of the tables, using the subwindow in figure \ref{fig:addentry}

\begin{figure}[ht]
  \centering
  \subfloat[Passwords are shown and do not match\label{fig:addentrya}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntrya.png}}
  {}
  \subfloat[Passwords are shown and do match\label{fig:addentryb}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntryb.png}}
  {}
  \subfloat[Passwords are shown. zxcvbn library has not been compiled\label{fig:addentryc}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntryc.png}}
  \caption{Add Entry subwindow}
 \label{fig:addentry}
\end{figure}

This subwindow is composed of:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Text input elements: }To enter the Username, Domain, Description and Password, five \texttt{QLineEdit} are used. The password needs to be entered twice to make sure is the desired one, and if it is not the same in both text fields, an error message is displayed. The date is not entered by the user, but generated automatically based on the system clock.
\item \textbf{Show password checkBox: }By changing the echo mode in the password \texttt{QLineEdit}, it can be hidden or shown. It is hidden by default
\item \textbf{Password Generator Button: }This triggers one of two available generators: PwGen or PassPhraseGen. These are explained in detail in sections \ref{sec:pwgen} and \ref{sec:ppgen}
\item \textbf{l33t buttons: }To increase the password strength the user can translate it to l33t. If they are not happy with the result, a button to reverse the action is also present. The l33t implementation is explained in section \ref{sec:l33t}
\item \textbf{Password Strength elements: } A Progress Bar used to display the password strength calculated with the zxcvbn library, a label to show some information about the strength, and a button to open a subwindow showing the details of these calculations. If the zxcvbn library has not been compiled by the user in the settings window, these elements are disabled. The zxcvbn library is explained in details in section  \ref{sec:zxcvbnim}
\item \textbf{Bottom buttons: }The \texttt{ok} button is only functional when all the text fields (except for \texttt{description}, which is optional) are filled, and the two passwords coincide. The \texttt{settings} button opens the settings subwindow so the user can customize the password generators or the strength estimator without having to close the \texttt{AddEntry} subwindow.

\end{itemize}

When the user clicks the \texttt{ok} button, the new entry needs to be added to the database. Instead of using SQLite commands, it is easier to rely in the high-abstraction level methods offered by the \texttt{model}, as seen in listing \ref{lis:addtomodel}.


\begin{lstlisting}[style=customc, float=htb, caption={Add entry to database using model}, label = {lis:addtomodel}]
AddEntry *add = new AddEntry(this);
add->exec(); //exec AddEntry subwindow
if(add->result()==QDialog::Rejected)
  return; // Error or cancel, do nothing

QSqlRecord rec = model->record(); // Temp entry
rec.setGenerated("id", false); // is managed by SQLite

//Get the values entered by user in AddEntry subwindow
rec.setValue("Username"   , add->getUser());
rec.setValue("Password"   , add->getPassword());
rec.setValue("Domain"     , add->getDomain());
rec.setValue("Description", add->getDescription());

rec.setValue("Date",        QDate::currentDate());//sys clock

int newRecNo = model->rowCount(); //insert at the end of table
if (!model->insertRecord(newRecNo, rec))
  return;
model->submitAll();// if insert ok, submit changes.
\end{lstlisting}

\subsubsection*{Edit Entry action}

The user can edit any of the entries by selecting one of the cells in the \texttt{tableView} and clicking the \texttt{Edit Entry} button, or by double-clicking any of the cells. In either case, the data from the selected row is retrieved and passed to new \texttt{AddEntry} object using its constructor. In this way, the user is presented with an \texttt{AddEntry} subwindow where the input fields are already filled with the current data. The user can then modify and save them by clicking \textsc{ok}. In this process the \texttt{ProxyModel} is used instead of the \texttt{model}, because the former allows to identify the items selected in the \texttt{tableView}.

\subsubsection*{Delete Entry action}

Deleting an entry is very simple. The row index of the selected cell is used in the \texttt{ProxyModel} method \texttt{removeRow(row)}, and the change is submitted with \texttt{submitAll}. Before deleting, the user is asked to confirm the action.

\subsection{Other functionalities}
In this section, a set of miscellaneous functionalities are explained.

\subsubsection*{Launch Domain action}

Using the Qt function \texttt{QDesktopServices::openUrl(QUrl(domain))}, it is straight forward to open the domain of the entry selected by the user. It will be opened in the default web browser configured in the OS. The only detail to play attention is the format. If the domain entered by the user does not start with \texttt{http://} or \texttt{https://}, then \texttt{http://} is prepended. Also, if the entered domain does not contain any dots apart from the one in \texttt{www.}, then the most common top-level domain, \texttt{.com} is added. This will not work in all the cases, but should help fixing some of the domains when the user forgets to type the TLD.


\subsubsection*{Status Bar}
The status bar, at the bottom of the main window, is used to display three types of information:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Wallet Name: }The wallet name (with full path) is permanently displayed at the right side of the status bar in color blue. In case the wallet does not have a name because the user has not saved yet, \texttt{unnamed} is displayed. When the wallet has unsaved changes, an asterisk is added to the end resulting in: \texttt{/absolute\_path/wallet\_name*} 

\item \textbf{Success: }After any save/open/delete operation, a black message is shown for two seconds in the left side of the status bar, informing the user the process concluded without issues.

\item \textbf{Error/Warning: }In the eventuality of an error or warning during the execution of a command, for instance, if it is not possible to load the SQLite driver, a red message in the left side of the status bar informs the user about the issue.
\end{itemize}


\subsubsection*{Preferences Subwindow}

This subwindow is accessible from the \texttt{Menu Bar} and from the \texttt{AddEntry} subwindow. It allows to customize the password generators and the strength estimator. Their available configurations are covered in their respective sections. 

\subsubsection*{Environment subwindow}

From the environment subwindow the user can select which of the keys and algorithms present in the SEcube™ chip to use for the encryption/decryption process. 

Keys are used to divide wallets into categories (work, banking, social) and allow their sharing.  A given user can have for instance one key that is shared among co-workers, so all of them can access work-related passwords using their respective SEcube™ devices. Similarly, other key can be shared with their family to access banking accounts passwords, and finally have a personal key that is not shared with anyone and is used to encrypt social media passwords. 

The current SEcube™ firmware version only includes one algorithm for the data encryption/decryption process, but in the future it may provide more than one. Different algorithms offer different security characteristics that some advance user may find useful. For example one user could be concerned about some specific type of attack that requires an special algorithm, or regard one algorithm superior over the others. 

Figure \ref{fig:envi} depicts the environment subwindow.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.5\columnwidth]{chapters/figures/development/envi.png}}
  \caption{Environment subwindow}
  \label{fig:envi}
\end{figure}


\subsubsection*{Help Subwindow}

This subwindow teaches the user a few tips about how to use the application features, some of which may not be obvious, like the strength estimator or the date filter. It also  gives some information about the application, like the author, year, and code sources.



\subsubsection*{l33t} \label{sec:l33t}

This is a very simple converter that uses the capabilities of the \texttt{QString} class to replace each occurrence of the letters \texttt{o i z E A s b T B P} with the numbers \texttt{0 1 2 3 4 5 6 7 8 9} respectively, and the letter \texttt{l} with the character \texttt{|}. To un-l33t, the reverse process is made. It is worth noticing that password crackers (and strength estimators like zxcvbn) usually try an l33t dictionary too, so this option may increase the password strength, but not by too much. In table \ref{tab:l33t} a few passwords and their l33t version are compared. The strength measured with zxcvbn is reported.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{A few l33t examples}
\begin{tabular}{lr}
\toprule
\textbf{Password} & \textbf{Log Entropy (Level)} \\ \midrule

LeytonVariational & 9.44 (Level 3) \\
Leyt0nVar1at10na| & 10.22 (Level 4) \\
\midrule
PenicuikCiting & 9.09 (Level 3) \\
9en1cu1kC1t1ng & 13.87 (Level 4) \\
\midrule
LauraDrogheda & 6.44 (Level 3) \\
LauraDr0gheda & 6.74 (Level 4) \\

\bottomrule
\end{tabular}
\label{tab:l33t}
\end{table}

\subsection{PwGen: Pronounceable Passwords Generator} \label{sec:pwgen}
As seen from previous sections, the PwGen program is open source and available in the official Linux repositories. A very simple way of including its functionalities into the SEcubeWallet application would be to use a \texttt{Qprocess} to call PwGen as an external program. Although is tempting to use this solution because of its simplicity, there are three drawbacks with this approach:

\begin{enumerate}
\setlength\itemsep{0pt}
\item It would require for the user to install the PwGen program, as it is usually not included in common Linux distributions.
\item It would not be very portable, because even if there is a PwGen version for windows, the available version or input parameters could differ in different platforms.
\item Security could be compromised. As PwGen needs to communicate the generated password back to the SEcubeWallet application, an attacker could steal the password in this process.
\end{enumerate}

For these reasons, it was decided to embed the PwGen sources directly into the application, this ensure the password never leaves the application memory space. 
To include the sources into the application, some slight modifications (mostly simplifications) to the PWGen \texttt{main()} function were necessary. This is because the original sources are intended for the use of PwGen as a independent console program called by users, so the \texttt{main()} contains code dedicated to parse the input arguments in the standard \texttt{argc argv[]} fashion. Only the \texttt{pwgen.c} and \texttt{pwgen.h} --- files where the \texttt{main()} is implemented --- were modified.

\subsubsection*{Options GUI}
As all the options for PwGen besides the password length are yes or no questions, the checkable list shown in figure \ref{fig:pwgenSett} is perfect for this purpose.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/pwgenSett}
  \caption{PwGen settings in the preference window}
  \label{fig:pwgenSett}
\end{figure}

When the \texttt{OK} button is clicked, all the values are saved using the \texttt{QSettings} class, so they are available even after restarting the application.

\subsubsection*{Usage}

When the \texttt{Generate Password} button in the \texttt{AddEntry} class is clicked, the settings values stored in with the \texttt{QSettings} class are read and from them a \texttt{char[]} with the PwGen options syntax is built. Before calling the Generator, it is necessary to allocate a memory space equal to the desired password length (in \texttt{char}) and pass this buffer as a pointer (\texttt{char*}) to PwGen. PwGen will write the generated password in this space. This steps can be seen in the listing \ref{lis:pwgen}


\begin{lstlisting}[style=customc, float=htb, caption={PwGen call inside AddEntry}, label = {lis:pwgen}]
//read user settings (if existent)
if (settings.value("passGens/pwgen/1cap").toBool())
    options.append("c");
if (settings.value("passGens/pwgen/1num").toBool())
    options.append("n");
if (settings.value("passGens/pwgen/1spec").toBool())
    options.append("y");
if (settings.value("passGens/pwgen/noAmb").toBool())
    options.append("B");
if (settings.value("passGens/pwgen/noCap").toBool())
    options.append("A");
if (settings.value("passGens/pwgen/noNum").toBool())
    options.append("0");
if (settings.value("passGens/pwgen/noVow").toBool())
    options.append("v");
if (settings.value("passGens/pwgen/random").toBool())
    options.append("s");

//check if user entered an integer, if not, default is 16
if(settings.value("passGens/pwgen/len").toInt())
    length = settings.value("passGens/pwgen/len").toInt();

//allocate space for password
buf = (char*)malloc(length+1);
if(!buf){
  return;//error, could not allocate
}
//actual call to password generator
main_pwgen(
  options.length(),               //int, number of options 
  options.toLatin1().constData(), //char *, options 
  length,                         //password length 
  buf                             //char *, to return the password           
);
genPass = QString::fromLatin1(buf,length);
free(buf);
\end{lstlisting}

\subsubsection*{Results}

A few examples of the resulting Passwords are show in table \ref{tab:pwgenExm}, with their respective zxcvbn Log entropy score and Level. As expected, the passwords with highest entropy are those obtained using the \texttt{-s} (Random) and \texttt{-sy} (Random and especial characters) options. Even with only 6 characters it is possible to get a Level 4 password like \texttt{TBw4)9}. The drawback is, they are hard to remember and type. 

On the contrary, a password obtained with the \texttt{-BA0} (No ambiguous, do not capitalize, no numbers, pronounceable) options, like \texttt{nofosootei}, only reaches a Level2, but it is very easy to remember and type.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{A few PwGen generated passwords}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{4cm}ccr
@{}}
\toprule
\hd{Password} & \hd{Length} & \hd{Options} & \hd{Log Entropy \\ \& Level}  \\ \midrule

iesohGhai3   & 10 & -   &  9.75 (Level 3)\\
ees0cooLo2   & 10 & -   & 10.47 (Level 4)\\
dX042wKqlW   & 10 & s   & 17.86 (Level 4)\\
@!,Q*l5\}+H  & 10 & ys  & 18.15 (Level 4)\\
TBw4)9       &  6 & ys  & 11.62 (Level 4)\\
B7t34Lck     &  8 & v   & 11.87 (Level 4)\\
nofosootei   & 10 & BA0 &  6.50 (Level 2)\\
\bottomrule  
\end{tabular*}
\label{tab:pwgenExm}
\end{table}

\subsection{zxcvbn Password strength estimator} \label{sec:zxcvbnim}

The original zxcvbn project, developed in CoffeeScript became so popular it was ported to a large variety of languages. In this work the C/C++ version available at \cite{zxgit} was used. The files used in this project are:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{zxcvbn.c} Main source file
\item \textbf{zxcvbn.h} Main header file
\item \textbf{dict-generate.cpp} Used for generating the dictionary sources
\item \textbf{Makefile} To compile the dictionary generator and main program.
\item \textbf{words-*.txt} A few examples of dictionary files in plain text format.
\end{itemize}

Besides source files, zxcvbn also needs to compile the dictionary files, but first lets define what is a dictionary, why are they important and why they need to be compiled (For general dictionaries only. User dictionaries are small and can be added at runtime).

\subsubsection*{General dictionaries}

Dictionaries are a crucial part of the algorithm, because they are used estimate the security level of a password according to how common the used words (if any) are. A password containing words present in any of the dictionaries will be easier to crack as hackers will probably try out those specific words or a combination of them.

General dictionaries contain a large number of words that are useful for all users. Examples of these type of dictionaries (included in this work) are:
\begin{itemize}
\setlength\itemsep{-3pt}

\item 100000 English words from wikipedia.
\item 88800 Last names from the US census database
\item 39000 English words from tv and film from the wikiproject \cite{wiktionary}
\item 47000 Most common passwords from Burnett \cite{burnett}
\item 15480 Italian words from the \textsc{badip} project \cite{badip} 
%TODO
\todo{More dicts, see bookmarks}
\item 4276 Female names from the US census database 
\item 1220 Male names from the US census database
\end{itemize} 

As the dictionary files in plain text are pretty large, the algorithm does not read from them directly. Instead, a \texttt{DicNodes} array is generated, using the tool \texttt{dict-generate}, and this array is compiled into the source code.
To add their own dictionaries, the users need to make sure they are saved as plain-text, (.txt UTF-8), and stored into the zxcvbn directory. The files must have one word per line, with the first word being the most common one. So for instance, in the English dictionary the first word is \texttt{the} and the last one is \texttt{surma}. This is important as it is used to calculate the entropy of the passwords. A password containing the word \texttt{surma} is far more secure that one containing the word \texttt{the}.

\subsubsection*{Static Library vs Shared Library}

Because the dictionaries are transformed into a source file and then compiled together with the main program, it is not possible to add, remove or modify dictionary files after the sources are compiled. Therefore the zxcvbn library can not be embedded into the SEcubeWallet application as a static library (or using the C sources directly), but rather, a \textbf{shared library} approach was followed, which allows the dynamic unload/update/load of the library. This has some performance penalties over static libraries, but it is the only way to give the users the possibility of customize the dictionaries as they please.

\subsubsection*{Compilation process}

The steps performed by the \texttt{makefile} in order to compile the dictionaries and sources are:

\begin{enumerate}
\setlength\itemsep{-3pt}

\item Compile the source file \texttt{dict-generate.cpp} to obtain the dict generator executable\texttt{dictgen}.
\item Execute \texttt{dictgen} with the names of dictionaries to process as input argument. As a result the file \texttt{dict-src.h} is created.
\item Compile the files \texttt{zxcvbn.c} and \texttt{zxcvbn.h} together with the just generated \texttt{dict-src.h}, using the gcc flag \texttt{-fPIC} so the resulting object file \texttt{zxcvbn-inline-pic.o} is suitable for library inclusion.
\item Generate the shared library \texttt{libzxcvbn.so} from the object file. This is the library used by the SEcubeWallet sources.
\end{enumerate}

The compilation process can be started by the user from the preference window, where they can also select the dictionaries to use, or clean the generated files. The compiling is made with OS calls, through the use of \texttt{QProcess}. To avoid the application from crashing or getting stuck, the \texttt{Qprocess} has a timeout. As the compile process may take a while depending on the dictionaries size, this timeout can be configured by the user. In figure \ref{fig:zxcvbnGen} the GUI for these actions is shown.

\begin{figure}[ht]
  \centering
  \subfloat[Tab dedicated to zxcvbn preferences]{\includegraphics[width=0.5\textwidth]{chapters/figures/development/zxcvbnGen.png}}
  \subfloat[Checkable dialogue to enable dictionaries, appears after clicking the Choose button]{\includegraphics[width=0.4\textwidth]{chapters/figures/development/dictListSett.png}}
  \caption{zxcvbn general dictionaries configuration}
 \label{fig:zxcvbnGen}
\end{figure}

\subsubsection*{Dynamic Library loading}

To manage the zxcvbn shared library at runtime it is possible to use the qt class \texttt{Qlibrary}, which provides access to the functionality in the library in a platform independent way. To use it, is necessary to pass as argument to the constructor the path to the library. Then load it and resolve the desired functions. If no errors are found, the functions can be used as usual. Finally unload the library when it is not needed any more. See Listing \ref{lis:qlibrary}.


\begin{lstlisting}[style=customc, float=htb, caption={Qlibrary basic usage}, label = {lis:qlibrary}]

/***** In header file *****/
//Main zxcvbn function type
typedef double (*ZxcvbnMatch_type)(const char *Passwd, 
                                   const char *UserDict[], 
                                   ZxcMatch_t **Info );
//Function used to free the Info structure
typedef void (*ZxcvbnFreeInfo_type)(ZxcMatch_t *Info);

QLibrary * zxcvbnLib = 0;
ZxcvbnMatch_type ZxcvbnMatch = 0;
ZxcvbnFreeInfo_type ZxcvbnFreeInfo = 0;

/***** In cpp file *****/     
zxcvbnLib = new QLibrary(zxcvbn_lib_path);
    
if(zxcvbnLib->load()){
  ZxcvbnMatch = (ZxcvbnMatch_type) zxcvbnLib->resolve("ZxcvbnMatch");
  ZxcvbnFreeInfo =(ZxcvbnFreeInfo_type) zxcvbnLib->resolve("ZxcvbnFreeInfo");
}

if (!ZxcvbnMatch || !ZxcvbnFreeInfo ){
  //error: Any of the two functions was not resolved correctly
else{
  //we can use the functions normally
  
//When not needed any more
zxcvbnLib->unload();
ZxcvbnMatch = 0;
ZxcvbnFreeInfo = 0;
free(zxcvbnLib);  
  
\end{lstlisting}


\subsubsection*{User Dictionaries}

The user dictionary contain words that are relevant only to a specific user. For example, if the application is used to increase the strength level of passwords used by employees in a company, adding the company's name to the dictionary is a good idea. Furthermore, if the company works in the automotive business, related words as motor, aerodynamic, wheels etc. should be added. By adding those words to the user dictionary, the strength level of passwords using them will decrease, and so the user will be encouraged to never use words that are too easy to guess. The key to a good password is in its randomness. When a hacker is trying to crack one, they will for sure try words relevant to the target.

From the GUI the user can add words manually, or can load them from a text file, but as the words are saved as a simple array, the text file size should not be too large. For large files, it is better to add them as General dictionaries.

\subsubsection*{Estimator Usage}

After the library is loaded and the functions resolved, to use the estimator one simply needs to call the main function \texttt{ZxcvbnMatch} whose declaration we see in Listing \ref{lis:zxcvbn} 

\begin{lstlisting}[style=customc, float=htb, caption={ZxcvbnMatch function declaration}, label = {lis:zxcvbn}]
double ZxcvbnMatch(       //Returns: entropy value in bits.
 
  const char *Passwd,     //The password to be tested. Null terminated string. 
  
  const char *UserDict[], //User supplied dictionary words to be considered particulary bad. Passed as a pointer to array of string pointers, with null last entry (like the argv parameter to main()). May be null or point to empty array when there are no user dictionary words. 
  
  ZxcMatch_t **Info       //The address of a pointer variable to receive information on the parts of the password. This parameter can be null if no information is wanted. The data should be freed by calling ZxcvbnFreeInfo().
);
\end{lstlisting}

To obtain the password strength level, it is necessary to compare the \texttt{zxcvbnMatch} return value (The entropy in bits) as seen in section \ref{sec:zxLevels}. The strength level is shown to the user with a progress bar.
%TODO
\todo{talk about models and table}
To the user may be more relevant to see some estimates about how long it would take for an attacker to crack the password. This information can be obtained from the entropy, assuming some numbers for the attempts/time the attacker can perform. These results are shown in a table like the one in figure \ref{fig:zxcvbnTimes}
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=1\columnwidth]{chapters/figures/development/zxcvbnTimes}
  \caption{Crack times for different attacker capabilities}
  \label{fig:zxcvbnTimes}
\end{figure}

Some interesting additional information can be obtained from \texttt{ZxcMatch\_t ** Info}. By traversing the data in this pointer, it is possible to see how the zxcvbn algorithm broke down the password. The user can see this information in a table like the one in figure \ref{fig:zxcvbnBreak}
\begin{figure}[htb]    
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.9\columnwidth]{chapters/figures/development/zxcvbnBreak}
  \caption{Password broke down by the zxcvbn algorithm}
  \label{fig:zxcvbnBreak}
\end{figure}



\subsection{PassPhrase Generator} \label{sec:ppgen}

The \texttt{PassPhraseGen} C++ function implements the PassPhrase Generator. The function call is done from the \texttt{AddEntry} class, when the \texttt{Generate Password} button is clicked.

\texttt{AddEntry} reads the configuration values stored as \texttt{QSettings}, asserts them and then makes the call. This values can be modified by the user in the preferences window, shown in figure \ref{fig:ppgenSett}. After the user selects the dictionaries and tunes the available options, they must click the apply button, which will trigger a line by line read of the dictionaries, to count the number of lines, that is the number of words available. This is necessary as it is not possible to know how many lines a file has without counting them, and the total number is required in order to generate properly bounded random numbers in the PassPhraseGen function.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/ppgenSett.png}
  \caption{Settings for PassPhrase Generator}
  \label{fig:ppgenSett}
\end{figure}

The function declaration is shown in listings \ref{lis:ppgen}


\begin{lstlisting}[style=customc, float=htb, caption={PassPhraseGen function declaration}, label = {lis:ppgen}]
QString PassPhraseGen(  //Return: Generated PassPhrase
  QString path,         //path to dicts
  QStringList dicts,    //list of dicts
  QStringList dictsLen, //cumulative list of dics lengths
  int totalLen,         //total number of candidate words
  int numWords,         //number of words in the password
  bool ppgenMinLenEnab, //use only words longer than min len
  int ppgenMinLen,      //min length
  bool capFirst,        //uppercase first letter of each word
  bool ppgenLowerEnab,  //use only lower part of dicts
  int ppgenLower        //how much of the lower part to use
);
\end{lstlisting}

The function first generates \texttt{numWords} random numbers in the range \texttt{[1, totalLen]} with the Qt function \texttt{QRandomGenerator} (introduced in version 5.10). The generated numbers represent \textsl{Line numbers} in the dictionary files. As each line contains a word, the function indeed extracts random words. There are a few things to consider in this process:
\begin{enumerate}
\setlength\itemsep{-3pt}

\item It is impossible to read a random line from a TextFile without reading all the previous lines first. So, in order to extract the words it is necessary to read the dictionary line by line and keep a counter to know the number line we are at. To speed up the process making sure each line is read only once, the random numbers are sorted in ascending order first. The dictionary can then be read line by line extracting the words where the counter equals one of the random numbers. When the last random line is extracted, the file can be closed.

\item There can be multiple dictionaries. The generated random numbers span the total of available words, so some random lines will be in some dictionaries, some in others. Therefore, using the \texttt{dictsLen} list, which contains the cumulative lengths of the dictionaries, we need to determine in which dictionary and in which internal line, each random number is. With this information, and the random numbers ordered, it is possible to extract the words efficiently and making sure dictionary files are opened only if necessary and only once.

\item When the minimum length option is enabled, the total number of available words is reduced. The algorithm accounts for this fact by counting only the lines with a word larger than the minimum length. This is done both in the preference window, where the total number of lines is counted, and at the word extraction process. In this way, the random lines are pinpointed as before, by reading line by line and comparing the counter; the working logic is not altered, it just ignores the "disabled" short lines.

\item Finally, to consider only the lower part of each dictionary the preferences window counting process is not altered, and the modifications are all done at the extraction process. If for example, the user wants to work with the lower 30\%, the random generated numbers are now bounded to \texttt{[1,  (0.3)totalLen]}. The corresponding dictionary and internal line for each random number are calculated by taking into account that the first 70\% of each dictionary must be skipped. With this two values, the files can be read as in the simple case. As this process is different from the minimum length one, they do not interfere with each other.

\end{enumerate}

Table \ref{tab:ppgenExm} presents some PassPhrases examples for different configurations, along side the score given by the zxcvbn estimator. The estimator uses the same dictionaries as the generator, so this assumes a worst case scenario where the hacker has access to all the possible words the user considered when creating the PassPhrase.

Two dictionaries where used: \texttt{words-eng\_wiki.txt} with 100000 lines and \texttt{words-it\_badip.txt} with 15480 lines (around 6 times smaller), so most of the extracted words will be English.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{PassPhrases examples for different configurations}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{6.5cm}cccr
@{}}
\toprule
\hd{PassPhrase} & \hd{No. of \\ words} & \hd{Min.\\word \\ Len} & \hd{\% of \\ dict.\\ used } &\hd{Log \\ Entropy \\ \& Level}\\ \midrule

		 Cocchio & 1 & - & - & 4.27 (L1) \\ 
		 Melun   & 1 & - & - & 4.93 (L1) \\ 
		 
		 Legitimately & 1 & 8 & - & 4.55 (L1) \\
     
     Woodhaven		& 1 & 8 & 30\% & 4.94 (L1) \\
     \midrule
     VestaOrman    & 2 & - & - & 7.78 (L2) \\    
     ShorelineCech & 2 & - & - & 9.18 (L3) \\
     
     MongoliaSimpsons & 2 & 8 & -    & 7.30 (L2) \\
     McinnisPhaya     & 2 & - & 30\% & 9.14 (L3) \\

     ZucchiniSalamandra & 2 & 8 & 30\% & 9.19 (L3) \\
     SacchettiVigevano  & 2 & 8 & 30\% & 9.11 (L3) \\

     DrammaturgicoSbatacchiare  & 2 & 12 & - & 8.98 (L3) \\
     MalformationsAstrophysical & 2 & 12 & - & 9.60 (L3) \\
     \midrule
     LatinaInterchangeFbo & 3 & - & - & 13.5  (L4) \\
     OsaAymanCantinflas   & 3 & - & - & 12.98 (L4) \\
     ImmobileCwSites      & 3 & - & - & 11.43 (L4) \\
     
     RimmelBragFaenza     & 3 & - & 30\% & 13.49 (L4) \\
     
     RecliningCanberraEcuadorian         & 3 & 8 &  -   & 13.69 (L4) \\
     
     
     SeashellsHippocraticCameroun        & 3 & 8 & 30\% & 14.90 (L4) \\
     InaspettatoRothschildsDisconcerting & 3 & 8 & 30\% & 14.48 (L4) \\
\bottomrule
\end{tabular*}
		\label{tab:ppgenExm}
\end{table}

The results in the table indicate the most important parameter is the number of words. Three words are enough to reach a zxcvbn level 4, which, as seen in previous sections, is very secure. A two word PassPhrase as long as \texttt{DrammaturgicoSbatacchiare} is not better than the shorter \texttt{ImmobileCwSites}, because the latter has one more word. The minimum word length also influences the PassPhrase entropy, but their effects are not as pronounced. Finally, working only with to the lower part of the dictionary may seem to not have any effect, but in reality its use is crucial: it ensures the generated PassPhrases do not contain any of the most common words, like \texttt{the} or \texttt{essere}. From the results on the table we can not appreciate this fact, but at least we learn the option does not do any harm either. (Although if the attacker finds out the user is generating PassPhrases using only the 30\% most uncommon words on a given language, their job would get easier).


\subsection{The FAT32 bug} \label{sec:fat32bug}
During the application development a strange and elusive bug was found: The \texttt{secureSQLite} library did not work properly with the FAT32 file system. When the save directory was in a FAT32 system, (either a partition, an external hard disk or an USB stick), the created databases were not stored properly, and when trying to open them they were completely empty. Only the database name was saved; any table in the wallet was lost. Moreover, after saving, besides the \texttt{.sqlite} file, a \texttt{.sqlite-journal} was created. Figure \ref{fig:fat32} depicts the presences of this file in a FAT32 file system.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.55\columnwidth]{chapters/figures/development/fat32.png}}
  \caption{secureSQLite Databases in a FAT32 file system}
  \label{fig:fat32}
\end{figure}

This file is known as a rollback journal and is used by the SQLite standard to avoid database corruption when a transaction can not be completed. From the SQLite official documentation \cite{journal}:
``The rollback journal is always located in the same directory as the database file and has the same name as the database file except with the 8 characters "-journal" appended. The rollback journal is usually created when a transaction is first started and is usually deleted when a transaction commits or rolls back. The rollback journal file is essential for implementing the atomic commit and rollback capabilities of SQLite. Without a rollback journal, SQLite would be unable to rollback an incomplete transaction, and if a crash or power loss occurred in the middle of a transaction the entire database would likely go corrupt without a rollback journal.
The rollback journal is usually created and destroyed at the start and end of a transaction, respectively. But there are exceptions to this rule.
If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a "hot journal" in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction.''

The presence of the journal file hints at the problem being an interruption during the execution of \texttt{secureSQLite} write functions when working on a FAT32 system. A few test were performed to try to narrow down the error origin:

\begin{itemize}
\setlength\itemsep{-3pt}

\item The application was tested in other computer running a different OS, and the problem persisted, always in FAT32 systems, meaning it was not an OS specific issue.
\item The application \texttt{secureSQLiteBrowser} which also uses the secureSQLite library was tested and presented the same problem, meaning it was not an error in the library usage.
\item The demo applications \texttt{SEfile\_IMG}  and \texttt{SEfile\_TXT} were also tested, and worked without any problems in FAT32 partitions. These applications do not use \texttt{secureSQLite}; they leverage directly the \texttt{SEfile} library, which is also used by the \texttt{secureSQLite} library, meaning the problem was not in \texttt{SEfile} but in \texttt{secureSQLite}. This was proved to be a wrong assumption later on.
\end{itemize}

With these points in mind, the bug was searched inside the \texttt{secureSQLite} library, but after several debug sessions, it was possible to trace the error origin to the \texttt{SEfile} library. Specifically, in the file \texttt{SEfile.c}, and function \texttt{secure\_seek}. Figure \ref{fig:traceback} shows the actual traceback, from the call to \texttt{sqlite3\_exec} in the \texttt{Save\_Wallet} action, all the way up to the \texttt{secure\_seek} function.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.8\columnwidth]{chapters/figures/development/traceback.png}}
  \caption{Error Traceback}
  \label{fig:traceback}
\end{figure}

The actual error is produced in the call to the OS function \texttt{lseek()} in line \ref{line:error} of listing \ref{lis:secseek}. 
\begin{lstlisting}[style=customc, float=htb, caption={FAT32 Error origin at secure\_seek}, label = {lis:secseek}, escapechar=¬]
/**This function is used to move correctly the file pointer.
 * [in]  hFile     The handle to the file to manipulate.
 * [in]  offset    Amount of character we want to move.
 * [out] position  Pointer to int32_t to store the final pos.
 * [in]  whence    Move from file start, end or current pos.
 * [return]        Returns '0' in case of success.*/
uint16_t secure_seek(SEFILE_FHANDLE *hFile, int32_t offset, int32_t *position, uint8_t whence){
  ...  
  buffer_size = *position - file_length;
  if(buffer_size>0){ ¬\label{line:buffer}¬
    //if destination exceed the end of file, empty sectors are inserted at the end to keep the file consistency
    buffer=calloc(buffer_size, sizeof(uint8_t));
    if(buffer==NULL)
      return SEFILE_SEEK_ERROR;
    
    if((file_length%SEFILE_LOGIC_DATA)){
      errno = 0; //clear errno 
      hTmp->log_offset=lseek( // the error is produced here ¬\label{line:error}¬
        hTmp->fd, 
        ((file_length%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE), 
        SEEK_END);
      error = errno;//capture errno, 22 when in FAT32 systems
      if(hTmp->log_offset==4294967295)
        //lseek returns (off_t)-1 when error. off_t is 32 bits, so 2^32-1 = 4294967295
        return SEFILE_SEEK_ERROR; //the upcoming secure_write call fails anyway
      
      if(secure_write(&hTmp, buffer, buffer_size)){
        free(buffer);
        return SEFILE_SEEK_ERROR;
      }   
\end{lstlisting}

\vspace{15pt}
The \texttt{lseek()} function, as defined in the linux manual page \cite{lseek}:

\texttt{\textcolor{blue}{off\_t} lseek(\textcolor{blue}{int} fd, \textcolor{blue}{off\_t} offset, \textcolor{blue}{int} whence);}

``\textbf{\texttt{lseek()}} repositions the file offset of the open file description
       associated with the file descriptor \texttt{fd} to the argument \texttt{offset}
       according to the directive \texttt{whence} as follows:
       
       \texttt{SEEK\_SET} The file offset is set to offset bytes.
       
       \texttt{SEEK\_CUR} The file offset is set to its current location plus offset bytes.
       
       \texttt{SEEK\_END} The file offset is set to the size of the file plus offset bytes.
lseek() allows the file offset to be set beyond the end of the file
       (but this does not change the size of the file)
       
\textbf{Return Value:} Upon successful completion, \texttt{lseek()} returns the resulting offset
location as measured in bytes from the beginning of the file.  On error, the value \texttt{(off\_t) -1} is returned and \texttt{errno} is set to indicate the error.''

\vspace{7pt}
\texttt{secure\_seek()} can be seen as a wrapper that uses the OS function \texttt{lseek()} to move the file pointer correctly, taking into account the way the \texttt{SEfile} library redefines a file, including the overhead added by sectors and headers that allow the data to be encrypted.

\vspace{7pt}       
To better understand what was causing the error, the \texttt{return} and \texttt{errno} values for two save operations of the same database were compared. One into a FAT32 file system and the other into a ext4 system.

When the FAT32 system was used, the \texttt{return} value was indeed \texttt{(off\_t)-1}, and the \texttt{errno}, was set to \texttt{22}, which corresponds to:

``\texttt{EINVAL}:  \texttt{whence} is not valid.  Or: the resulting file offset would be negative, or beyond the end of a seekable device.''

When saving into an ext4 file system, the \texttt{return} value was \texttt{9844} and \texttt{errno} was equal to zero.

\vspace{7pt}
Figure \ref{fig:errordebug} shows this difference, and it is worth noticing that besides the file descriptor and pointers (always different for different executions), the rest of the variables have the same value
\begin{figure}[ht]
  \centering
  \subfloat[FAT32 filesystem]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/fat32debug.png}}
  {}
  \subfloat[ext4 filesystem]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/ext4debug.png}}
  \caption{Return and errno values for a save operation}
 \label{fig:errordebug}
\end{figure}

Going back to the \texttt{secure\_seek()} code in listing \ref{lis:secseek}, the line \ref{line:error} moves the file pointer to the last \texttt{LOGIC\_DATA} byte, because in order to keep the file consistency, its is required to write empty sectors starting from this position until the end of the file. To do so, starting from the end of the file (thus the argument \texttt{SEEK\_END}), the function moves the pointer backwards the number of empty bytes in the last sector.

In order to move backwards, the \texttt{offset} argument of \texttt{lseek()} must be negative. In this case, the argument is equal to: 

\lstset{style=customc}
\lstinline"offset = (file_length%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE"

Which should always be always negative, but it turns out, in the case of the FAT32 file system, this offset is not interpreted as a 2's complement negative value, but as a very large positive one. Therefore, the \texttt{lseek()} function tries to move the pointer outside the file limit, explaining the error: \texttt{EINVAL}: the resulting file offset would be negative, or beyond the end of a seekable device.

\vspace{7pt}
To fix the error, a simple cast to \texttt{\textcolor{blue}{int32\_t}} for the \texttt{offset} argument is enough, resulting in the call:
\vspace{5pt}

\lstinline|hTmp->log_offset=lseek(|

\lstinline|  hTmp->fd,| 

\lstinline| (int32_t)((file_lengh%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE),| 

\lstinline|  SEEK_END);|
\vspace{7pt}

This kind of casting was actually found in other function calls in the \texttt{SEfile.c} file, so it made sense to use it in this situation too.

\vspace{7pt}
The reason the problem only affected FAT32 partitions is probably related to the fact that, as \texttt{lseek()} needs to move a file pointer, low-abstraction level functions need to be used, which are have different implementations for each type of file system. The ext4 low level functions were able to interpret the offset as negative whereas the FAT32 took it as positive.

Why the error only appears when using the \texttt{secureSQLite} library, and not in the demo applications \texttt{SEfile\_IMG} and \texttt{SEfile\_TXT} honestly remains a mystery. It may be  that the condition in line \ref{line:buffer} of listing \ref{lis:secseek} (\lstinline|if(buffer_size>0)|), that evaluates if the destination exceeds the end of file, is only met in rare occasions, and the way SQLite journaling works is one of them.
