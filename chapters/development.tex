\chapter{Application Development}

%\section{Requirements (and Specifications)}
%TODO
\todo{req and spec}

\section{Useful concepts definition}

More detailed explanations of the following concepts will be given later on, but it is helpful to shortly define them here so this work is more readable.

\subsection{Wallet} A password wallet is a digital form of securely keeping passwords and some meta information. In this work, a Wallet is stored as a SQLite DataBase. A wallet can have as many tables as the user wants. For instance an user could have a table for storing social media passwords, another one for work-related passwords and a last one for credit cards and bank accounts passwords. Finally, each table has a set of defined fields (Username, Domain, Password, Date, Description).

\subsection{SEcube} SEcube™ is a custom chip produced by the Blu5 group \cite{Blu5} that integrates an ARM CPU, a FPGA and a SmartCard. The chip is specifically designed for security purposes, allowing developers to implement encryption/decryption functions that are executed fast and are guaranteed to be reliable. The chip can be connected to a PC using popular protocols like USB and Ethernet, so an application running on the PC can use the SEcube™ to encrypt/decrypt some data.

\subsection{SEcube™ SDK} The SEcube™ Open SDK is a set of open libraries designed to make the development of applications using SEcube™ more convenient. There are two types of Libraries: Host side (PC) and device side (SEcube) libraries. In general host side functions make requests to device side functions and wait for their response. Moreover, libraries are divided in four and two hierarchical levels of abstraction, for host and device side respectively. Level0 and Level1 are the lowest levels and are present in both host and device. L0 provides the communication protocols while L1 provides basic security APIs.

\subsection{SEfile} 
SEfile is a Level 2 API that allows users to encrypt/decrypt data (files in the hard disk), so they can only be read when the SEcube™ chip is connected to the PC. When the SEcube™ is not connected, it is impossible to read the files as the information necessary to decrypt them is physically stored in the SEcube.

\subsection{SQLite DB}
%TODO
\todo{SQLite}

\section{Design}

The purpose of this section is to give the reader a clear overview of how the application works in general terms. 

A simplified design architecture is displayed in figure \ref{fig:BasicDesign}. It shows which Software Libraries are used by the application and when it uses them.


\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{chapters/figures/development/BasicDesign.pdf}
	\caption{Basic Design: Used Libraries}
	\label{fig:BasicDesign}
\end{figure}

The following is a brief explanation of these Libraries and they usage. More details about each Library and why they were chosen are given in section \ref{sec:lib} and section \ref{sec:imp} deals with the actual implementation.

\subsection{L0 and L1 Authentication libraries}

When the user starts any application based on the SEcube™ platform, the first steps to perform are to open the communication with the device using Level0 functions from both host and device, and to authenticate the user by checking the login pin, using Level1 functions (again, from both sides). Figure \ref{fig:BasicDesign} depicts how the SEcubeWallet uses the authentication functions and they in turn communicate with the SEcube™ chip.

\subsection{secureSQLite3}
As explained before, Wallets are stored as SQLite DataBases. Fortunately, the SEcube™ SDK already provides a Level2 API for creating and managing encrypted SQLite DBs, called secureSQLite3. This API exploits the SEfile API to wrap some of the functions of the original SQLite3 library, avoiding OS calls.

secureSQLite allows to create/edit/save/open databases that when written to the disk are encrypted and can only be read when the SEcube™ is connected. Additionally, as it is implemented using wrappers, the developer only needs to include the source files in the project and can manage secureSQLite DB with the same functions used for regular SQLite DB. %TODO
\todo{cite secureSQLite}

Figure \ref{fig:BasicDesign} shows the SEcubeWallet application using secureSQLite to read/write the encrypted wallet stored in disk.

\subsection{SQLite3}
Because the use of secureSQLite involves a call to the SEcube™, a regular SQLite3 DB is also used, but unencrypted data is never saved to the disk. SQLite3 allows for the creation of an In-Memory DB, i.e. a DB whose content is always in the application's memory space and is therefore secured by the operating system. 

The In-memory DB is used for editing. When the user want to save the wallet, i.e. write it to the disk, the contents of the In-Memory DB are dumped to the encrypted secureSQLite DB. When the user opens a wallet from the disk, the reverse process occurs.

With the In-memory DB, unnecessary calls to the SEcube™ are avoided while maintaining the contents secured.

\subsection{Password Generator}
As the purpose of the application is to securely store passwords, said passwords should be as strong as possible. It does not make sense to protect a password that can be easily cracked by a hacker using brute force. That is why the application also includes a Password Generator.

PwGen \cite{pwgen} is an open source library that generates passwords, that can either be easy to remember, or completely random. Random passwords are more secure, but as the are difficult to remember, their use only makes sense when the user stores them in a wallet manager. Among other aspects, length and characters used (Numbers, Upper cases) can be configured too.

When the user is adding a new entry to a wallet, they can chose to enter a password or to automatically generate one.

\subsection{PassPhrase Generator}
In addition to the Password Generator PwGen, the user has the possibility to generate PassPhrases instead. PassPhrases are a popular alternative because they are easier to memorize and therefore can be longer, which in turns make them more secure. Further details about the usefulness of PassPhrases and how they compare against regular Passwords is given in section \ref{sec:zxcvbnth}.

Although the PassPhrase Generator is not a library per se, it was included in the diagram because of its close relation with the PwGen and zxcvbn \cite{zxgit} libraries. It was developed by the author, and it works by selecting random words out of dictionary files. 

The user can configure how many words each passphrase must have, the minimum length of said words, and which dictionary files to use, among other options.

\subsection{Strength Estimator}
To give the users feedback on how good the password they are about to store is, the application uses the open source project zxcvbn to give an estimation of the passwords entropy, and how long it would take for a hacker to break it. zxcvbn evaluates if the password is a common word, or a combination of them, a last name, a date, or letters close to each other in a keyboard (thus the name zxcvbn). With the estimator users are encouraged to create good passwords that are not necessarily completely random and difficult to remember, or annoying to type.

%\vspace{15pt} 
\vskip 25pt

To recap, these are the key aspects of the used libraries:

\begin{itemize}
\setlength\itemsep{0pt}

\item To start the connection with the SEcube™, the Level0 library is used
\item To authenticate the user, by checking if the entered login pin is the same as the pin stored in the SEcube™, the Level1 library is used.
\item An in-memory database is used for editing the wallet.
\item An encrypted in-disk data base is used for storing the wallet in disk.
\item The application includes a password generator with several options.
\item The application also includes a password strength estimator, so the user has an idea of how good their passwords are.

\end{itemize}

\section{Frameworks, Libraries and software tools} \label{sec:lib}

As explained in the previous section, the core of the design is the use of the SEcube™ chip to perform security operations in order to encrypt/decrypt some data stored in the host (PC). The requests to the chip are made from the Qt application developed in this work, which runs in the host. Said application exploits the existing C libraries SEfile and secureSQLite to ease the communication with the SEcube™. Additionally, the application also makes use of a random password generator PwGen and a strength estimator zxcvbn open libraries. 

In the following sections a review of the SEcube™ platform's hardware and software components is given. Then a brief explanation of the C++/Qt framework and why it was chosen. Finally the additional used libraries are presented.

\subsection{The SEcube™ framework}

``The SEcube™ (Secure Environment cube) Open Security Platform is an open source security oriented hardware and software platform, designed and constructed with ease of integration and service-orientation in mind. The hardware part of the platform was originally designed by Blu5 Group \cite{Blu5}, whereas the software libraries stem from a strong cooperation among international research institutions.'' \cite{GetStart}.

\vspace{5pt}

The main \textbf{hardware} products, explained in detail in the following sections, are:
\begin{itemize}
\setlength\itemsep{0pt}
\item The Chip, named SEcube™ Chip, or simply \textbf{SEcube™}
\item The Development Board, named \textbf{SEcube™ DevKit}
\item The USB Stick, named \textbf{USEcube Stick}.
\end{itemize}

The SEcube™ chip is the main hardware component, and both the devkit and USB Stick are designed around it.The Development Board provides several communication protocols as well as debugging capabilities. For the final product the board would be of course too inconvenient to carry, and instead the USEcube Stick is preferred.

\subsubsection{The SEcube™ Chip}

``The SEcube™ (Secure Environment cube) is a powerful chip which
integrates three key security elements in a single package. A fast
floating-point Cortex-M4 \textbf{CPU}, a high-performance \textbf{FPGA} and an
EAL5+ certified Security Controller (\textbf{Smart Card}).
The result of this innovative combination gives an extremely
versatile secure environment in a single SoC, in which developers
can rapidly implement complex applications and appliances.
... The SEcube™ is the ultimate solution for high-end design,
delivering integration of a flexible, configurable and certified
secure element.'' \cite{SEcubeDS}

We can then see the SEcube™ chip as a powerful device offering the flexibility of an \textsc{ARM} CPU, the speed of an FPGA and the reliable security of a certified Smart Card, all bounded together and easily integrated in any project thanks to the available communication protocols, among them USB, UART, Ethernet and JTAG. 

The chip includes a true random number generator which relies in 240 noise seeds, all physical and therefore unpredictable. This allows the creation of true random noise. Additionally the user can choose what type of noise they want to generate, for instance white or Fourier noise.

%TODO
\todo{talk more about cpu, low power modes...}

In figure \ref{fig:SEcubeBD} a simplified SEcube™ architecture is shown.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{chapters/figures/development/SEcubeBlocks.png}
	\caption{SEcube™ Block Diagram}
	\label{fig:SEcubeBD}
\end{figure}


\subsubsection{Development board: The SEcube™ DevKit}

The development board integrates the SEcube™ chip with several peripherals that allow the user to easily communicate, program and debug. (Figure \ref{fig:devboard})

\begin{figure}[ht]
  \centering
  \subfloat[]{\includegraphics[width=0.485\textwidth]{chapters/figures/development/devboard.jpg}}
  \subfloat[]{\includegraphics[width=0.515\textwidth]{chapters/figures/development/devboard_sch.png}}
  \caption{SEcube™ Devkit}
 \label{fig:devboard}
\end{figure}

The main peripherals in the SEcube™ devkit are:

\begin{itemize}
\setlength\itemsep{-3pt}
\item \textbf{J1000: }\tabto{2.3cm} USB 2.0 to UART 
\item \textbf{J2000: }\tabto{2.3cm} Ethernet 10/100 socket 
\item \textbf{J4000: }\tabto{2.3cm} SEcube™ embedded FPGA and CPU GPIOs
\item \textbf{J4001: }\tabto{2.3cm} SEcube™ embedded CPU JTAG
\item \textbf{J4002: }\tabto{2.3cm} microSD card 
\item \textbf{J4004: }\tabto{2.3cm} SEcube™ embedded FPGA and CPU GPIOs
\item \textbf{J5000: }\tabto{2.3cm} USB 2.0 High Speed 
\item \textbf{LEDx:  }\tabto{2.3cm} Leds 
\item \textbf{SWx00y:}\tabto{2.3cm} Switches 
\end{itemize}

\subsubsection{Final product: USEcube Stick}

For the final product, its is desired that the user carries all the SEcube™ functionalities in a small and convenient package, so they can encrypt/decrypt the passwords in any PC by just connecting the USEcube Stick and running the SEcubeWallet application.

The USEcube Stick is compatible with any Operating System and the SEcube™ functionalities are easily exposed to applications and services without installing any driver.

The USEcube offers only the strictly required components: The SEcube™ chip, a USB 2.0 High-Speed interface and an SDcard socket. See Figure \ref{fig:USEcube} for more details.


Since the USEcube Stick storage capability is based on a external microSD card, the security of the system is improved, as this allows to have a separation of encrypted data from the encryptor/decryptor. Additionally, both the size and the speed can be tuned per the user requirement and can be changed at any time, just replacing the microSD, without buying a new USEcube Stick.
The microSD card socket is embedded in the USB connector allowing to save space making the USEcube Stick very compact and, at the same time dust
and water-resistant.
Since the USEcube Stick is not provided with the JTAG interface, to inject the firmware previously developed and tested on the SEcube™ DevKit, all the devices come with an embedded secure boot loader.


\begin{figure}[ht]
  \centering
  \subfloat[]{\includegraphics[width=0.485\textwidth]{chapters/figures/development/usb.png}}
  \subfloat[]{\includegraphics[width=0.515\textwidth]{chapters/figures/development/usb_sch.png}}
  \caption{USEcube Stick}
 \label{fig:USEcube}
\end{figure}


\subsubsection{L2 Security APIs}

``The software libraries and design environment allow developers who are not willing or able to produce the security APIs and protocols themselves to exploit the ready functions provided (currently as APIs and soon as services) within the SEcube™ platform and experience the platform as a high-security black box.'' \cite{L2UserMan}





``From the user/developer point of view, the APIs have been implemented targeting two
nested environments depending on where physically the code runs:
\begin{itemize}
\setlength\itemsep{1pt}
\item \textbf{Device-Side}, including the libraries of basic functionalities that are executed on the embedded processor of the SEcube™-based hardware device.
\item \textbf{Host-Side}, containing libraries of functions executed on the host PC and interface functions for calling services and processes residing on the embedded processor of the SEcube™ device.
\end{itemize} 

From the architectural point of view, the Host-Side Libraries have been implemented targeting 4 hierarchical abstraction levels, and namely:
\begin{itemize}
\setlength\itemsep{-3pt}
\item \textbf{Level 0:} Communication Protocol and Provisioning APIs
\item \textbf{Level 1:} Basic Security APIs (Level1 Host-Side – L1)
\item \textbf{Level 2:} Intermediate Security APIs (Level2 – L2)
\item \textbf{Level 3:} Advanced Security APIs (Level3 – L3).
\end{itemize}

At each level, each component represents a "service" for the upper level and relies on "services" provided by the next lower level, only.'' \cite{L2UserMan}

``Level L2 relies on L1 services to provide the APIs for implementing more abstract secure functionalities. Typical examples include APIs for the protection of data both at rest and in-motion, or negotiating parameters (e.g., keys, algorithms) for establishing secure sessions, without being forced to understand in details all the low-level hardware and security mechanisms.''\cite{L2UserMan}

L2 can be considered as the merge of two projects: \textbf{SEfile}, concerning data at rest, and \textbf{SElink}, concerning instead data at motion.

For our project we rely heavily on the development tools provided by the SEfile project, for the secure storage, usage and retrieve of data that requires a high degree of confidentiality, in our case, digital passwords.

\subsubsection{SEfile}

``SEfile targets any user that, by moving inside a secure environment, wants to perform basic operation on regular files. It must be pointed out that all encryption functionalities are demanded to the secure device in their entirety. In addition, SEfile does not expose to the host device details about what, or where it is reading/writing data: thus, the host OS, which might be untrusted, is totally unaware of what it is writing''. \cite{L2UserMan}.

\subsubsection{secureSQLite}

\subsection{SQLite3}

\subsection{Graphical User Interface: the Qt framework}
The application's graphical user interface was developed using the \textbf{Qt framework}, version 5.8.0. 

``Qt is a cross-platform application development framework for desktop, embedded and mobile. Supported Platforms include Linux, OS X, Windows, VxWorks, QNX, Android, iOS, BlackBerry, Sailfish OS and others. Qt is not a programming language on its own. It is a framework written in C++. A preprocessor, the MOC (Meta-Object Compiler), is used to extend the C++ language with features like signals and slots. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC''.\cite{Qt}  


For writing, compiling and debugging source code, the IDE \textbf{Qt Creator}, version 4.2.1 was used.

``Qt Creator provides a cross-platform, complete integrated development environment (IDE) for application developers to create applications for multiple desktop, embedded, and mobile device platforms, such as Android and iOS. It is available for Linux, macOS and Windows operating systems''.\cite{QtC}.

\vspace{5pt}
The reasons behind the use of Qt are as follows:

\begin{itemize}
\setlength\itemsep{0pt}
\item Qt is a C++ library, and as such, allows for a seamless use of the C libraries SEfile and secureSQLite, which are the backbone of this project.

\item Qt is cross-platform, meaning the developed application can be compiled to work on any of the major OSes. In particular, the development was carried out an tested on a Linux machine, but the application should work with no problems in Windows and MacOS. 

\item Because of good designed and ready-to-use display items such as tables, menus and dialogues, it is possible to focus in writing the functional portions of the application without worrying too much about the GUI. And as it is open source, any Qt item can be modified and extended when it does not meet the expectations out of the box. In this project several display elements were improved, as will be seen in section \ref{sec:imp}.

\item Thanks to the multitude of functions dedicated to ease the use of C++ libraries and OS calls, one can be more productive, and the resulting code is more reliable. For instance, this project makes extensive use of such libraries, like QSqlDatabase, QString, QProcess, etc. Again, more details are given in section \ref{sec:imp}

\item Related works by research group \textsc{testgroup} from Politecnico di Torino using the SEcube™ framework, are written in Qt. Namely secureSQLiteBrowser and SEfile\_TXT, were used as base in the initial stages of development. This two projects can be found in the SEfileSDK available online \cite{SEcubeRes}.
%TODO
\todo{research group name  TESTGROUP?}

\item Qt is widely used, meaning it is possible to find tons of documentation, forums and additional libraries on the web. This also ensures the Qt framework will have continuous support from the developers and the community.

\end{itemize}



\subsection{PwGen: Pronounceable Password generator}

The most secure type of passwords are random ones. A random password sufficiently long is considered to be virtually unbreakable. But this rises two problems: First of all, humans are inherently bad at creating true random passwords. Second, a random password is not suited to be remembered or even used (as it probably is too annoying to type). These two reasons motivated the inclusion of a Password Generator.

pwgen is an open source program that generates human friendly passwords that are also secure. It is available in the official Linux repositories, and there is a Windows version as well, but in this work the source files where used.

``The pwgen program generates passwords which are designed to be easily memorized by humans, while being as secure as possible. Human-memorable passwords are never going to be as secure as completely completely random passwords. In particular, passwords generated by pwgen without the -s option should not be used in places where the password could be attacked via an off-line brute-force attack. On the other hand, completely randomly generated passwords have a tendency to be written down, and are subject to being compromised in that fashion'' \cite{pwgen}.

pwgen offers several options that can drastically change the type of generated password. Here is a list of the options available for users of SEcubeWallet:

\begin{itemize}
\setlength\itemsep{0pt}


\item \textbf{Length:} The desired length of the password. It is recommended to be at least 12 for non-random passwords and 8 for random ones.

\item \textbf{-0, no numerals:} 
Don't include numbers in the generated passwords. 

\item \textbf{-A, no capitalize:} 
Don't bother to include any capital letters in the generated passwords. 
    
\item \textbf{-B, ambiguous:}
Don't use characters that could be confused by the user when printed, such as 'l' and '1', or '0' or 'O'. This reduces the number of possible passwords significantly, and as such reduces the quality of the passwords. It may be useful for users who have bad vision, but in general use of this option is not recommended. 
    
\item \textbf{-c, capitalize:}
Include at least one capital letter in the password.

\item \textbf{-n, numerals:}
Include at least one number in the password.

\item \textbf{-s, secure:}
Generate completely random, hard-to-memorize passwords.

\item \textbf{-v, no vowels:}
Generate random passwords that do not contain vowels or numbers that might be mistaken for vowels. It provides less secure passwords to allow system administrators to not have to worry with random passwords accidentally contain offensive substrings. 

\item \textbf{-y, symbols:}
Include at least one special character in the password.
\end{itemize}

By default pwgen behaves as if the options \textbf{-nc} were used, that is, pronounceable passwords with at least 1 capital letter and 1 number.

The strongest passwords this program can generate are obtained with the options \textbf{-ys}, as it results in random passwords with special symbols. They are very hard to remember, and should only be used if the user is willing to open the SEcubeWallet application each time they need to use one of the password.


\subsection{zxcvbn: Password strength estimation} \label{sec:zxcvbnth}

An important feature to have in a password manager is the possibility to realistically estimate how strong a password is, i.e., how hard could it be for hackers to crack it, as there is no point in using the SEcube™ system to protect weak passwords, that could be easily guessed with brute force attacks. As it is out of the author expertise to write a reliable function to make this estimation, it was decided to use a trusted project developed during the dropbox hackweek event in 2012. The estimator called \textbf{zxcvbn} was originally written in JavaScript aiming for an easy integration with multiple web browsers and OS. Fortunately, the community ported the library to a wide variety of languages including Python, Ruby and C/C++. In this work the C++ implementation was used. The project is Open Source and available for free use on GitHub \cite{zxgit}.

zxcvbn is regarded by the community as one of the most reliable and mathematically advanced open source password estimators. In security forums and discussion it always pops out as an excellent tool, much better than other passwords estimators commonly used in web pages. In \cite{naked}, the author compares zxcvbn to other popular java meters and arrives to the conclusion that only zxcvbn is reliable enough to actually give an useful feedback.
In \cite{gen_est_eval}, the author makes an evaluation of several password generators and strength estimators. PwGen and zxcvbn, the two libraries used in this work, always give excellent results.

``For over 30 years, password requirements and feedback have largely remained a product of LUDS: counts of Lower- and Uppercase letters, Digits and Symbols. LUDS remains ubiquitous despite being a conclusively burdensome and ineffective security practice. zxcvbn is an alternative password strength estimator that is small, fast, and crucially no harder than LUDS to adopt. Using leaked passwords, we compare its estimations to the best of four modern guessing attacks and show it to be accurate and conservative at low magnitudes, suitable for mitigating online attacks. We find 1.5 MB of compressed storage is sufficient to accurately estimate the best-known guessing attacks up to 105 guesses, or 104 and 103 guesses, respectively, given 245 kB and 29 kB. zxcvbn can be adopted with 4 lines of code and downloaded in seconds. It runs in milliseconds and works as-is on web, iOS and Android''. \cite{zxpaper}

``People of course choose patterns — dictionary words, spatial patterns like \texttt{qwerty}, \texttt{asdf} or \texttt{zxcvbn}, repeats like \texttt{aaaaaaa}, sequences like \texttt{abcdef} or \texttt{654321}, or some combination of the above. For passwords with uppercase letters, odds are it’s the first letter that’s uppercase. Numbers and symbols are often predictable as well: \texttt{l33t} speak (3 for e, 0 for o, @ or 4 for a), years, dates, zip codes, and so on.
As a result, simplistic strength estimation gives bad advice. Without checking for common patterns, the practice of encouraging numbers and symbols means encouraging passwords that might only be slightly harder for a computer to crack, and yet frustratingly harder for a human to remember. xkcd nailed it''. (see figure \ref{fig:xkcd}). \cite{zxdropbox}

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=\columnwidth]{chapters/figures/development/xkcd.png}
  \caption{Password strength, xkcd \cite{xkcd}}
  \label{fig:xkcd}
\end{figure}

To put it in other words, the authors of the project argue that a password like \texttt{correcthorsebatterystaple} (a nonsense English phrase) is more strong than a password like \texttt{Tr0ub4dour\&3}, even if the former does not have any upper cases or numbers, and the latter seems more complicated.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=\columnwidth]{chapters/figures/development/zxcvbn_comp.png}
  \caption{comparison between zxcvbn and popular websites' strength meters}
  \label{fig:tablez}
\end{figure}

The table in figure \ref{fig:tablez} (taken from \cite{zxdropbox}), show how zxcvbn is different from strength meters used in popular web services. (disclaimer: The data in the table is from 2012). From it we can learn:

\begin{enumerate}
\setlength\itemsep{-3pt}

\item Passwords like \texttt{\textbf{qwER43@!}}, which is a spatial password: it uses the keys \texttt{qwer4321}, with shift pressed for the keys \texttt{er} and \texttt{21} (the \texttt{@} symbol in the English keyboard is \texttt{shift+2}), is not considered week by most of the meters, but it should. It is probably due to the fact that it includes a combination of numbers and symbols that makes it look strong, but in reality, because of keyboard spatiality, is not.

\item Passwords like \texttt{\textbf{Tr0ub4dour\&3}}, which is generated by replacing some of Troubadour letters with numbers, and adding two more characters, is regarded as a very strong password for all of the meters except zxcvbn. Even if the base word is uncommon, and it has some variations, it is not long enough to be considered so strong.
\item A password like \texttt{\textbf{correcthorsebatterystaple}} is not considered strong by most of the meters except zxcvbn, and it is not even allowed in some cases because it lacks numbers, Upper-cases or symbols.
\end{enumerate}

The superiority of zxcvbn over the other meters in the table may seem like cherry picking, but the way zxcvbn is constructed explains these differences.

\subsubsection*{Matching}

Enumerates all the (possibly overlapping) patterns it can detect. Currently zxcvbn matches against:

\begin{itemize}
\setlength\itemsep{-3pt}


\item \textbf{Dictionaries:} Common words the user is likely to use as password. Multiple dictionaries, in a simple .txt format can be used. In this work, we present a few: English words, Italian words, names and surnames, Burnett’s 10,000 common passwords, words from tv and films. The match has an associated frequency rank, where words like the and good have low rank, and words like photojournalist and maelstrom have high rank. This lets zxcvbn scale the calculation to an appropriate dictionary size on the fly, because if a password contains only common words, a cracker can succeed with a smaller dictionary. For all dictionaries, match recognizes uppercasing and common \texttt{l33t} substitutions.

\item \textbf{Spatial keyboard patterns:} Some users are likely to choose passwords based on spatial pattern. For instance a user could choose the first row of letters from right to left: \texttt{poiuytrewq} as they password. \textsc{qwerty} keyboard, Dvorak keyboard, and keypad are considered.

\item \textbf{Repeats}: Users are also prone to use repetition of characters, like \texttt{rrrr}. 

\item \textbf{sequences}: Numeric or alphabetic sequences like \texttt{123} or \texttt{fedcba}

\item \textbf{years and dates}: The year or full date of a special event, like anniversary or birthday. Years from 1900 to 2019 are considered and dates in different formats. (3-13-1997, 13.3.1997, 1331997). 

\end{itemize}

\subsubsection*{Entropy calculation of a single pattern}
Depending on the type of matching, the entropy calculation is done differently, but for all the cases the idea is the same: How many different cases a hacker would have to try before guessing the pattern? For example, for the repeat case, if the user chooses \texttt{zzzzz}, as it is repeated five times, and if we assume the hacker starts by the letter a, then the number of cases would be $ N = 26 \times 5 = 130 $. (The sequence the hacker would try is: \texttt{a, b, c, d...,z, aa, bb, cc,...,...,zzzz, aaaaa, bbbbb,....zzzzz}).


As the number of possible cases can be pretty large, the entropy is not given as a raw value but as $e = log_{2}(N)$, known as the entropy bits, and in some cases as $f = log_{10}(N)$, known as the log entropy. In the example, entropy bits: $e = log_{2}(130) = 7 bits$.

The entropy bits and log entropy are related by:
\[N = 2^{e} = 10^{f}\]
\[f = e \times log_{10}(2)\]
\[e = f \times log_{2}(10)\]


\subsubsection*{Minimum entropy search of whole password}

``Given the full set of possibly overlapping matches, the algorithm finds the simplest (lowest entropy) non-overlapping sequence. For example, if the password is damnation, that could be analysed as two words, dam and nation, or as one. It’s important that it be analysed as one, because an attacker trying dictionary words will crack it as one word long before two.

zxcvbn calculates a password’s entropy to be the sum of its constituent patterns. Any gaps between matched patterns are treated as brute-force "patterns" that also contribute to the total entropy. That a password’s entropy is the sum of its parts is a big assumption. However, it’s a conservative assumption. By disregarding the "configuration entropy" — the entropy from the number and arrangement of the pieces — zxcvbn is purposely underestimating, by giving a password’s structure away for free: It assumes attackers already know the structure (for example, surname-bruteforce-keypad), and from there, it calculates how many guesses they’d need to iterate through.''\cite{zxdropbox}

\subsubsection*{From entropy bits to rank and estimated crack time} \label{sec:zxLevels}

To estimate the cracking time, it is necessary to make some assumptions about what kind of attack will be subjected the user. zxcvbn considers four possible scenarios according to the number of attempts/time the hacker can do:

\begin{enumerate}
\setlength\itemsep{-3pt}


\item \textbf{Online throttling (100 per hour):} Online attack on a service that ratelimits password authentication  attempts.
  
\item \textbf{Online no throttling (10 per second): }Online attack on a service that does not ratelimit or where an attacker has outsmarted ratelimiting.

\item \textbf{Offline slow hashing (1e4 per second): }Offline attack. assumes multiple attackers, proper user-unique salting, and a slow hash function with moderate work factor, such as bcrypt, scrypt, PBKDF2.

\item \textbf{Offline fast hashing (1e10 per second): }Offline attack with user unique salting but a fast hash function like SHA1, SHA256 or MD5. A wide range of reasonable numbers anywhere from one billion to one trillion guesses per second, depending on number of cores and machines. Ballparking at 10B per sec.

\end{enumerate}

%  0 # . (guesses < 10^3)
%
%  1 # very guessable: protection from throttled online attacks. (guesses < 10^6)
%
%  2 # somewhat guessable: protection from unthrottled online attacks. (guesses < 10^8)
%
%  3 # safely unguessable: moderate protection from offline slow-hash scenario. (guesses < 10^10)
%
%  4 # very unguessable: strong protection from offline slow-hash scenario. (guesses >= 10^10)

zxcvbn then ranks a password with a security level from 0 to 4 according to its entropy value:
\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Level0 if ($N<10^{3}$):} Too guessable, risky password
\item \textbf{Level1 if ($N<10^{6}$):} Very guessable, protection from throttled online attacks.
\item \textbf{Level2 if ($N<10^{8}$):} Somewhat guessable, protection from unthrottled online attacks.
\item \textbf{Level3 if ($N<10^{10}$):} Safely unguessable, moderate protection from offline slow-hash scenario.
\item \textbf{Level4 if ($N>10^{10}$):} Very unguessable: strong protection from offline slow-hash scenario

\end{itemize}
Where N is the number of possibilities a hacker would have to try for crack the password. So for instance, if the password is level 2, it could be cracked in around $10^{8}$ guesses.

For Level0 the above rule in terms of the entropy bits is $e<log_{2}(10^{3})$.
In terms of the log entropy bits, it simply is $f<3$.

The level and estimated crack time for each type of attack is presented to the user. With this information, the user will, hopefully, choose a Level4 password. Additionally, the user also receives  feedback about how the password was cracked, so they know how to improve it.

\subsection{PassPhrase Generator}

From the previous two sections there seems to be a disagreement on what a good password looks like. PwGen can generate totally random passwords or pseudo-random pronounceable passwords, but even the later go against what zxcvbn proposes: PassPhrases that are very easy to remember, but long enough to give excellent entropy results. To fill this gap, a PassPhrase generator that gives results along the lines of \texttt{CorrectHorseBatteryStaple} is used.

The PassPhrase generator developed by the author works by randomly picking out words from dictionary files. The user can tune the PassPhrase generation as follows:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Dictionaries: }The user must select appropriate dictionaries, containing a sufficiently large number of lines (larger than 10000) to ensure the picked words are really random. The English and Italian dictionaries used by zxcvbn are a good example. The user can work with as many dictionaries as desired, an the format must be one word per line. Only the first word of each line is counted, as everything after a space is trimmed.

\item \textbf{Number of words: }The user can configure the number of words the generated PassPhrases are composed of. The recommended size is four, but it can be as long as the user wants.

\item \textbf{Minimum Length of Words: }With this option is possible to select only random words whose length is higher than a certain value. This is to make sure the resulting PassPhrase is too short and therefore too insecure. The drawback here is that the higher the selected threshold, the fewer the available words in the dictionaries.

\item \textbf{Only use infrequent words: }If the dictionaries follow the same format as those used for zxcvbn, that is, the words are ordered by frequency, having the most uncommon words in the lower part of the dictionary, the user can then ask to generate PassPhrases containing only unusual words. The drawback here is, again, fewer words to choose from. The percentage of words that are used is configurable.

\item \textbf{Capitalize first letter: }To make the PassPhrases more readable, the first letter of each word can be capitalized.
\end{itemize}



\subsection{Device side development: Eclipse}

\section{Implementation} \label{sec:imp}

%TODO
\todo{subdirs structue in qt project}

In the following sections each of the elements and functionalities of the application will be explained, how they were implemented, some interesting pieces of code and examples of use.

\subsection{User authentication}

When the user starts the application, the first window to appear is the Login Dialogue, shown in figure \ref{fig:logina}. In it the user is asked to enter the login pin and by clicking accept the Challenge-Based Authentication process between the SEcubeWallet application and the SEcube™ chip starts. If the authentication fails because the entered pin is wrong, the message in \ref{fig:loginb} is shown. If it fails because there was already an opened session, the confirmation dialogue shown in \ref{fig:loginc} appears. If the authentication is completed successfully the user is granted access to the main window.

\begin{figure}[ht]
  \centering
  \subfloat[Login Dialogue\label{fig:logina}]
  {\includegraphics[width=0.3\linewidth]{chapters/figures/development/login.png}}
  {}
  \subfloat[Wrong Password\label{fig:loginb}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginWrong.png}}
  {}
  \subfloat[Already an open session\label{fig:loginc}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginOpen.png}}
  \caption{Login Dialogue and possible outcomes}
 \label{fig:login}
\end{figure}

The authentication process begins with the discovery of SEcube™ devices connected to the PC. This is achieved using Level0 APIs as seen in the listing \ref{lis:dis}. Each discovered device is added to the \texttt{QComboBox} displayed in the login dialogue and to a \texttt{QList}.

\begin{lstlisting}[style=customc, float=htb, caption={Connected Devices discovery}, label = {lis:dis}]
//// *** variables declaration ***
se3_disco_it it;
QList<se3_disco_it> device_found;
QComboBox* chooseDevice;
bool found = true;

//*** Refresh button slot *****
L0_discover_init(&it); //initialize iterator
while((found = L0_discover_next(&it))){ //move to next device
  chooseDevice->addItem(QString::fromLocal8Bit(
    it.device_info.path, -1)); //add to GUI
  device_found.push_back(it); //add to QList
}
\end{lstlisting}

The user then selects one of the discovered devices using the \texttt{QComboBox}, enters their login pin and clicks accept. This triggers the listing \ref{lis:login}. The first step is to open the device communication using the Level0 function \texttt{L0\_open}. Then \texttt{L1\_login} starts the actual challenged based authentication using the login pin entered by the user. Using this type of authentication ensures the login pin is never communicated between the devices and stolen with a physical attack on the USB cable. Rather, a random number is generated in the host and transmitted to the device. The login pin is then used in both the host and the device to encrypt this random number using a \texttt{pbkdf2} function. The resulting key on the device is sent to the host, who compares it with its own key. If they are the same it means the login pin entered by the user is equal to the login pin stored in the device, and the only information transmitted are random numbers that an attacker cannot understand. (The actual authentication procedure implemented is a little bit more complex, but is based on the same idea described here).
%TODO
\todo{explain better the challenge based}

\begin{lstlisting}[style=customc, float=htb, caption={Open device and try to login}, label = {lis:login}]
// *** variables declaration ***
//use selected index at QComboBox to retrieve 'it' from QList.
int device_index = chooseDevice->currentIndex();
se3_disco_it it = device_found.at(device_index);

se3_session s; 
se3_device dev;
int ret;
bool logout = false; //if true, L1_login logs out first

//*** Accept button slot *****
if(!dev.opened) // open communication with device
  if((L0_open(&dev, &(it.device_info), SE3_TIMEOUT))!= SE3_OK)
    exit(1); //error

ret = L1_login(&s, &dev, pin, SE3_ACCESS_USER, logout); //login

if (ret != SE3_OK){    //error at login
  if (ret == SE3_ERR_PIN) //The password is wrong
    show_wrong_pass_messsage;
    
  else if (ret == SE3_ERR_OPENED){
    // there is already an opened session, ask user if he wants to close it
    if(confirmation_dialog_reply == Yes){ 
      logout = true; 
      call_this_function_again;
      //next time L1_login will close the existing session
    }
  }else            
    exit(1);//other error
}else
  accept();//All ok, go to main window
\end{lstlisting}

After both device and host have the same key, it is used to encrypt the communication channel. A token is generated in the device and transmitted on the encrypted channel to the host. This token is a random number, and is used from that point on to validate any communication between host and device. The SEcubeChip does not accept any command from the host if the token it sends is not the correct one. The only command accepted without a token is off course, login. In the logout procedure, this token is cleared (set to zeros), so a login later on is possible.

One problem found during the development of the application is the followin: If after login in, the SEcubeWallet application crashes, the logout command, that is usually issued when closing, is never executed, and the device remains with an active token value. Therefore, when the user launches the application again, the login will fail, because the device expects a token value from the host. To solve this issue a few options were considered:

\begin{itemize}
\setlength\itemsep{-3pt}

\item Make sure the application never crashes. Because software applications are rarely completely bug-free, and even if they are, an external problem like a bug in the OS can make them crash, this option is not feasible. 
\item Make sure the logout command is issued even in the case the application crashes. This option sounded promising, and a two-process idea was even developed. Process 1 is only in charge of calling Process 2, in which the actual application was executed. if Process 2 crashes, Process 1 remains alive and performs the logout procedure. To make this work, shared memory was used to communicate the session variable (were the token is stored), so both processes could send commands to the device. The idea was latter on dropped because of two main reasons: First of all, it did not solve the case were the problem is external (OS bug), secondly, it was too complicated because of the sharing memory mechanism (The session variable is a fairly complex structure, with a lot of pointers), and because the token was being shared by two processes, this could open another possibility of attacks.
\item As the two previous ideas failed, it was decided that a small modification to the login behaviour on the SEcube™ firmware was necessary. The modification consist on letting the login function clear the token field if necessary. This does not compromise the security of the system because access to the chip is only granted if the login pin entered by the user is the right one. One concern that may rise is that, while an application is using the SEcube™, another one could close the session by issuing a Login command, but this is not possible because the \texttt{L0\_open} function only allows one process to communicate with the chip at a time, using a file locker in the .se3magic
file saved in the SEcube™ SDcard.
\end{itemize} 

The new behaviour is implemented in listings \ref{lis:se3cmd1}.
If after a crash the session in the SEcube™ remains open, and the host tries to login again, the SEcube™ returns the new error code \texttt{SE3\_ERR\_OPENED}. The host then can decide if it wants to force the SEcube™ to close the opened session so it can login, with the new command \texttt{SE3\_CMD1\_LOGOUT\_FORCED}, which forces a logout without checking the token. After this command the host can login as usual. This steps are included in the host side \texttt{L1\_login} function, which now has an additional parameter to control whether to force a logout or not. This parameter is the one used in listings \ref{lis:login}, set to true when the user clicks \textsc{yes} in the confirmation dialogue asking whether or not to close the previous session.

\begin{lstlisting}[style=customc, float=htb, caption={Modification in SEcubeFirmware, file se3\_cmd1.c}, label = {lis:se3cmd1}]
if (se3c1.login.y) { // if there is already an opened session
  if (memcmp(se3c1.login.token, req_params.token, SE3_L1_TOKEN_SIZE)) { //and token mismatch
    if (req_params.cmd==SE3_CMD1_CHALLENGE)//someone (maybe same user after a crash) trying to login.
      return SE3_ERR_OPENED;//notify host there is already an opened session, if host wants to continue, it will call SE3_CMD1_LOGOUT_FORCED
    else if (req_params.cmd==SE3_CMD1_LOGOUT_FORCED)//if the user agreed to close the existing session by forcing a logout
      req_params.cmd=SE3_CMD1_LOGOUT;//call logout as usual  
    else
      return SE3_ERR_ACCESS;
  }
}
\end{lstlisting}




\subsection{Main Window}

The SEcubeWallet GUI's main window developed using Qt is shown in figure \ref{fig:mainWindow}.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=1\columnwidth]{chapters/figures/development/mainWindow.png}}
  \caption{SEcubeWallet main window}
  \label{fig:mainWindow}
\end{figure}

The main window is composed of the following elements:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Table View:} Used for displaying the wallet entries. It resizes smoothly with the window, can be ordered by any of the columns, and the passwords are hidden by default but can be shown if the user wants to.
\item \textbf{Filters:} The user can search in each of the table's columns using filters. These filters are implemented inside a separate container, but they resize together with the table.
\item \textbf{Entries Tool Bar:} It is positioned to the left of the table. It has the actions: add/edit/delete entries, show passwords, fit table, change date filter, launch domain and select table.
\item \textbf{Tables Tool Bar:} It is positioned to the top right of the table. It has the actions: add/rename/delete table.
\item \textbf{Wallets Tool Bar:} It is positioned to the top left of the table. It has the actions: new/open/delete/save/save as/close Wallet. 
All of the above Tool Bars are movable.
\item \textbf{Menu Bar:} It is positioned at the top of the window. It contains all the previous actions, plus preferences and help.
\item \textbf{Status Bar:} Positioned at the bottom of the window, it is used to display some success/error messages to the user and the current wallet name.
\end{itemize}

\subsection{Wallet actions}

The actions regarding wallets: New, Save, Save As, Open, Close and Delete are explained in detail in the following.

\subsubsection*{New Wallet action}

When the user triggers the the \texttt{New\_Wallet} action, the first step to execute is to check if there is another wallet opened and if it has unsaved changes. If, so the confirmation dialogue in figure \ref{fig:confSave} is shown, so the user can decide whether to save the changes, discard them, or cancel the creation of a new wallet.
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.6\columnwidth]{chapters/figures/development/confSave.png}}
  \caption{Save Confirmation dialogue}
  \label{fig:confSave}
\end{figure}

In case the user clicks \texttt{Save}, the \texttt{Save\_Wallet} action is triggered before continuing. \texttt{Discard} continues without saving, and \texttt{Cancel} returns without doing anything.

If the process continues, the next step is to close any previous in-memory database handlers, save the \texttt{table\_view} geometry (if any), and open a new in-memory database using the Qt class \texttt{QSqlDatabase}, as seen in listings \ref{lis:newDB}.

\begin{lstlisting}[style=customc, float=htb, caption={New in memory database}, label = {lis:newDB}]
QSqlDatabase dbMem; //The database handler, declared in header 

//Check if SQLite is installed on OS
if(!(QSqlDatabase::isDriverAvailable("QSQLITE")))
  exit (1); //the application does not work without SQLite

if (dbMem.isOpen()){ 
  save_table_geometry;
  dbMem.close();//close any prev. opened database
}

dbMem = QSqlDatabase::addDatabase("QSQLITE");
dbMem.setDatabaseName(":memory:"); // in-memory database
if(!dbMem.open()){
  return;//Error opening, do nothing
}
\end{lstlisting}

As explained before the in-memory data base is used for editing. It has the advantage of being fast because there is no access to the hard disk, and secure, because all the data is in the application memory space, and therefore is protected by the OS.

The last step is to update the GUI state, by enabling some action like \texttt{Add\_Table} and \texttt{Save\_Wallet}, and disabling others, like \texttt{Delete\_Table} and \texttt{Rename\_Table}.

\subsubsection*{Save Wallet action} \label{sec:savewalletaction}
To write the wallet contents to the disk, it is necessary to have a filename, so the first step is to check if the user already entered one (from previous saves). If not, with the dialogues in figure \ref{fig:saveWallet} the user can choose the directory and the filename to save.

\begin{figure}[ht]
  \centering
  \subfloat[User can enter a New name. Current wallets are displayed\label{fig:saveWalleta}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/saveWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Save Wallet dialogues}
 \label{fig:saveWallet}
\end{figure}

The need for two dialogues instead of a regular file browser comes from the fact that the chosen filename will not be readable from the OS, since \texttt{SEfile} also encrypts it. Similarly, wallets already saved in the directory cannot be displayed with a regular file browser, so it is necessary to use the \texttt{SEfile} function \texttt{secure\_ls} and display its output in the list seen in figure \ref{fig:saveWalleta}. The declaration of this function is in listings \ref{lis:securels}. To chose the working directory, it is enough to use the \texttt{QFileDialog} class. If the user wishes they chose an existing filename and can overwrite the correspondent wallet.

\begin{lstlisting}[style=customc, float=htb, caption={\texttt{secure\_ls} declaration}, label = {lis:securels}]
 /* This function identifies which encrypted files and encrypted directories are present in the directory pointed by path and writes them in list. It only recognizes the ones encrypted with the current environmental parameters.*/
 
uint16_t secure_ls(    //returns 0 in case of success
  char *path,          //[in]Path to the directory to browse
  char *list,          //[out]Allocated array to store filenames
  uint32_t *list_length//[out]Num of char written in list
);
\end{lstlisting}


After having a filename the next step is to read all of the tables in the current in-memory database, row by row. For each row a \texttt{SQLite} statement of the form \texttt{INSERT INTO table VALUES(user, dom, pass, date, desc)} is created. All of them are merge into a single statement which is executed into the secured in-disk database. This ensures only one access to the SEcube™ and disk. This process is somewhat slow and the GUI is disabled while it is performed. A simplified version of the code is shown in listing \ref{lis:save} 

\begin{lstlisting}[style=customc, float=htb, caption={simplified Save process}, label = {lis:save}, escapechar=¬]
sqlite3 *dbSec;    //Secure database declaration, in header
QSqlDatabase dbMem;//The database handler, declared in header 
QSqlQuery query;   //To exec SQLite statements, dec. in header

//Create SQLite DB, with filename specified by user If SEcube is connected, the resulting file is encry.
sqlite3_open_v2 (fileName.toUtf8(),   
                &dbSec, 
                SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE , 
                NULL) 
                
QString finalSql; //To Merge all the SQLite statements.
static const QString insert = 
  QStringLiteral("INSERT INTO '%1' VALUES(%2);"); //statement
  
dbMem.tables(QSql::Tables); //list of the tables in in-memory DB
tables.prepend("NoEmpty");  //Workaround: prepend Empty table   ¬\label{line:empty}¬
foreach (const QString table, tables) { // loop all the tables
   QString sql= "create table '"+table+//Create table statement 
                "'(id integer primary key, "
                "Username TEXT, "
                "Domain TEXT, "
                "Password TEXT, "
                "Date TEXT, "
                "Description TEXT );" ; 
  sqlite3_exec(dbSec, sql.toUtf8(), NULL, 0, &zErrMsg);// exec
  
  if (table=="NoEmpty"){//just an empty table
    set_values_to_empty;
    finalSql += insert.arg(table).arg(values.join(", "));
  }else{
    query.prepare(QString("SELECT * FROM [%1]").arg(table));
    query.exec()
    while (query.next()){ //row by row
      values = query_read_row();
      finalSql += insert.arg(table).arg(values.join(", "));
    }
}
//single write into secure database, fill the tables
sqlite3_exec(dbSec, finalSql.toUtf8(), NULL, 0, &zErrMsg);
\end{lstlisting}

One problem found during the open process of a secured in-disk wallet is that the first table is always corrupt and gives the error: \texttt{database disk image is malformed}. The error only occurs when using the SEcube™ version of the SQLite library. Because it was impossible to find the origin of the error, it was decided to use a workaround: In the save wallet process, an empty table is inserted at the beginning of the in disk database (see line \ref{line:empty} in listings \ref{lis:save}). When opening the wallets, the empty table is simply ignored. With this, the real tables are always correctly read an the application works as intended.


\subsubsection*{Save Wallet As action}

This action is very simple, it just clears the current filename (if any), and calls the \texttt{Save\_Wallet} action; as there is no filename, the user is forced to enter a new one. The only point to be careful about is that, in case the \texttt{Save\_Wallet\_As} process is aborted, the previous filename needs to be recovered, so before clearing, the filename is temporary stored in case it is needed.

\subsubsection*{Open Wallet action}
Similarly to the \texttt{New\_Wallet} action, the first step is to check for unsaved changes and ask the user if save them, discard them or cancel, with the dialogue in figure \ref{fig:confSave}

If the user decides to continue, the dialogues in figure \ref{fig:openWallet} allow them to choose from the list the wallet to open.

\begin{figure}[ht]
  \centering
  \subfloat[User chooses the wallet to open from the list\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/openWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Open Wallet dialogues}
 \label{fig:openWallet}
\end{figure}

The application proceeds doing the inverse process to the \texttt{Save\_action}, that is, read all the tables from the secure in-disk database and create an in-memory database with this data. To do so, the listings in \ref{lis:openWallet} is used. First, the in-disk data base is opened as read only, and a list named \texttt{tables} with the existent tables in it is generated. Then an in-memory database is created. Finally, for each table in \texttt{tables}, its contents are read, a correspondent table is created in the in-memory database, and the later is populated with the read contents from the in-disk DB.
\begin{lstlisting}[style=customc, float=htb, caption={Simplified Open Wallet action}, label = {lis:openWallet}]
sqlite3_open_v2(fileName.toUtf8(),
                &dbSec, 
                SQLITE_OPEN_READONLY, NULL)); //open in-disk DB

QString tableNames="SELECT name FROM sqlite_master "
                    "WHERE type='table' "
                    "ORDER BY name;";
sqlite3_exec(
  dbSec, tableNames.toUtf8(), 
  callback_createTableList,//builds the 'tables' list 
  this, &zErrMsg);

if (dbMem.isOpen()){ 
  save_table_geometry;
  dbMem.close();//close any prev. opened database
}
dbMem = QSqlDatabase::addDatabase("QSQLITE");
dbMem.setDatabaseName(":memory:");
dbMem.open();
query = QSqlQuery(dbMem);

foreach (const QString table, tables){
  QString sql = "create table '"+table+
                "'(id integer primary key, "
                "Username TEXT, "
                "Domain TEXT, "
                "Password TEXT, "
                "Date TEXT, "
                "Description TEXT );";
  if (table!="NoEmpty"){ //Workaround: ignore empty
    query.prepare(sql);
    query.exec(); //create table in in-mem DB
  }
  QString SqlStatement = 
    QStringLiteral("SELECT * FROM '%1';").arg(table);
  sqlite3_exec(
    dbSec, SqlStatement.toUtf8(), 
    callback_populateTable, //populates in-mem DB
    this, &zErrMsg);
}
\end{lstlisting}


The \texttt{SELECT FROM} statements in \texttt{sqlite3} require the use of a \textsl{callback} function, which is called for every result row, and receive the actual data from the data base as an \texttt{argv[]} argument. In the open process two of these functions are needed, shown in listing \ref{lis:callback}. 
In \texttt{create\_TableList}, the list \texttt{tables} is build by simply reading the only element in the \texttt{argv[]} array, as each row only consists of a table's name. 
In \texttt{populatetable}, the table in the in-memory DB is populated, row by row with each call.  In this case the \texttt{argv[]} array holds the values in a single row coming from the in-disk DB.

Finally the GUI is updated, by enabling some elements and disabling others.

\begin{lstlisting}[style=customc, float=htb, caption={Callback functions for Sqlite3 SELECT}, label = {lis:callback}]
//Build TableList from in-disk DB
callback_createTableList(int argc, char**argv, char**azColName){ 
  tables << argv[0]; //only one arg, the table name
  return 0;
}
//fill 'table' in in-mem DB with data from in-disk DB
callback_populateTable(int argc, char **argv, char **azColName){ 
  if (table=="NoEmpty") // we dont want NoEmpty in the in-mem db
    return 0;
  int i;  

  static const QString insert = 
    QStringLiteral("INSERT INTO '%1' VALUES (%2);");
  
  QStringList values;
  QString aux;
  for(i = 0; i<argc; i++){//argv holds values from a single row 
      aux = argv[i];
      values << "'"+aux+"'"; 
  }
  query.prepare(insert.arg(table).arg(values.join(", ")) );
  query.exec();
  return 0;
}
\end{lstlisting}


\subsubsection*{Close Wallet action}

This action is very simple. As usual, before closing the current wallet a check for unsaved changes is performed, and the user is asked what to do with them using a confirmation dialogue. If the user decides to continue, the in-memory database handler is closed, and the table geometries are saved. Finally the GUI is updated.

\subsubsection*{Delete Wallet action}

Deleting a wallet involves deleting an in-memory database and/or an in-disk database. 

If only the in-memory database exists (user has not save it to disk yet), the wallet is simply closed, as in the previous section.

If there is no opened wallet, and the user wishes to delete an in-disk database, a select file dialogue equal to the one in the \texttt{Open\_Wallet} action is shown, where the user can chose the wallet to delete. Then the wallet is deleted as shown in listing \ref{lis:delete}. First we obtain the encrypted version of the filename, using the SEcube™ API, and then the file in the disk is deleted using standard OS calls. 

\begin{lstlisting}[style=customc, float=htb, caption={Delete an in-disk database}, label = {lis:delete}]
crypto_filename(fileName.toUtf8().data(), 
                enc_filename, &enc_len 
                );
QFile::remove(enc_filename); //OS call
\end{lstlisting}

If both in-disk and in-memory wallets are to be deleted, that is, if there is an opened wallet that has been already saved to disk, there is no need for a select file dialogue, as the filename is known from the \texttt{Save\_Wallet} process. The in-memory database handler is closed and the in-disk encrypted wallet file deleted as explained above. 

In all the above cases, a confirmation dialogue ask the user if they are sure about deleting the wallet.

\subsection{Table actions and display}
Actions and classes regarding tables, they creation and display, are explained in the following sections: 

\subsubsection*{Add Table action}

With an in-memory wallet opened, the user can add a new table to it by simply entering a name. the listing \ref{lis:addTable} shows this process. With the \texttt{QIntputDialog} class, it is possible to ask the user for a name easily. If the name is valid, the sqlite query to add the table is executed. It may be the case the table already exists, in which case the query execution returns an error and the user is notified.

\begin{lstlisting}[style=customc, float=htb, caption={Add a New Table}, label = {lis:addTable}]
bool ok;
QString tableName = QInputDialog::getText
  (this, "New Table",
  "Enter new table name",
  QLineEdit::Normal,"", &ok);

if (!ok || tableName.isEmpty())
  return;

QSqlQuery query(dbMem);
query.prepare("create table '"+tableName+
              "'(id integer primary key, "
              "Username TEXT, "
              "Domain TEXT, "
              "Password TEXT, "
              "Date TEXT, "
              "Description TEXT )");

if (!query.exec()){
  return; // maybe a table with that name already exists, or is a reserved SQLite command
\end{lstlisting}

If the table is the first one to be added in the wallet, a \texttt{table view} and \texttt{filters} are created and added to the GUI, in order to display the table. Otherwise, the \texttt{table view} is just updated. These elements are explained in details in the upcoming sections.

\subsubsection*{Delete Table action}

To delete a table it is enough to use the SQLite \texttt{DROP TABLE} command as seen in listings \ref{lis:deleteT}. With the \texttt{QMessageBox} the user is asked to confirm before deleting.

After deleting, the \texttt{table view} needs to be updated, to show the next table in the wallet. If there are no more tables, the view is simply hidden, and other GUI elements like \texttt{Add Entry} disabled.

\begin{lstlisting}[style=customc, float=htb, caption={Delete Table}, label = {lis:deleteT}]
reply = QMessageBox::question
          (this,
          "Delete",
          "Are you sure you want to delete Table "+tableName,
          QMessageBox::Yes|QMessageBox::No);
if (reply == QMessageBox::No)
  return;

QSqlQuery query(dbMem);
query.prepare("DROP TABLE '" + tableName+"'");
\end{lstlisting}

\subsubsection*{Rename Table action}
To Rename a table the SQLite command \texttt{ALTER TABLE RENAME TO} is used as seen in listing \ref{lis:renameT}. After this, the \texttt{QComboBox} used to select the current table being displayed is updated to reflect the name change.
\begin{lstlisting}[style=customc, float=htb, caption={Rename Table}, label = {lis:renameT}]
QSqlQuery query(dbMem);
query.prepare("ALTER TABLE '" + currentName + "' RENAME TO '"+newName+"'");
query.exec();
\end{lstlisting}

\subsubsection*{Select Table}

To allow the user to select one table to display out of the existent ones in the current Wallet, a \texttt{QComboBox} is added to the Entries Tool Bar. Each time a Wallet is opened/closed, or a table is added/renamed/deleted, the items in the QComboBox are updated accordingly. When the selected item in the QComboBox changes, the tableView update procedure explained in the following section is triggered.

\subsubsection*{Table display}
To display the entries in each of the Wallet tables, a \textbf{Model/View} architecture was followed. From the official Qt documentation \cite{modelview}:
 
``Model-View-Controller (MVC) is a design pattern originating from Smalltalk that is often used when building user interfaces. In Design Patterns, Gamma et al. write:

MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.

If the view and the controller objects are combined, the result is the \textbf{model/view} architecture. This still separates the way that data is stored from the way that it is presented to the user, but provides a simpler framework based on the same principles.''

``The model communicates with a source of data, providing an interface for the other components in the architecture. The nature of the communication depends on the type of data source, and the way the model is implemented.

The view obtains model indexes from the model; these are references to items of data. By supplying model indexes to the model, the view can retrieve items of data from the data source.

In standard views, a delegate renders the items of data. When an item is edited, the delegate communicates with the model directly using model indexes.''

Figure \ref{fig:modelview} (taken from the Qt documentation), shows the way these three elements interact between them and with the data. 

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.5\columnwidth]{chapters/figures/development/modelview.png}}
  \caption{The Qt Model View Architecture}
  \label{fig:modelview}
\end{figure}

\begin{lstlisting}[style=customc, float=htb, caption={Model/View architecture implementation}, label = {lis:modelview}]
// Create and configure model to access data in table
model = new QSqlTableModel;
model->setTable(tableName);
model->select();//update the model selection
model->setEditStrategy(QSqlTableModel::OnManualSubmit);
  //Changes will be updated manually by calling submitAll()

//Create ProxyModel for filtering
proxyModel = new MySortFilterProxyModel(this);
proxyModel->setSourceModel(model); //connect proxyModel to Model

//Create and connect delegate to hide passwords
passDelegate=new PasswordItemDelegate(this);
ui->tableView->setItemDelegateForColumn(PASS_COL, passDelegate);

//Connect to table view, resulting in: 
//Sql <--> Model <--> ProxyModel <--> Delegate <--> TableView
ui->tableView->setModel(proxyModel);

//Configure table
ui->tableView->//Hide SQLite ID column, not useful to user
  setColumnHidden(IDENT_COL, true);
ui->tableView->//Hide row header, not useful
  verticalHeader()->hide();
ui->tableView->//To make the table view not editable
  setEditTriggers(QAbstractItemView::NoEditTriggers);
ui->tableView->//To allow only one row  selection.
  setSelectionBehavior(QAbstractItemView::SelectItems);
ui->tableView->//So we can edit one entry per time
  setSelectionMode(QAbstractItemView::SingleSelection);

ui->tableView->show();// show table
\end{lstlisting}

In the SEcubeWallet application these elements correspond to:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Data:} The data coming from the database. As we are displaying only one table at a time, the data actually corresponds to a single table.
\item \textbf{Model}: \texttt{QSqlTableModel}, a Qt class which provides an editable data model for a single database table.
\item \textbf{Proxy Model}: \texttt{MySortFilterProxyModel}, a class written by the author inheriting from the Qt \texttt{QSortFilterProxyModel} class. It implements custom filtering for each of the columns, in particular for the date.
\item \textbf{View}: \texttt{MyQTableView}, a class written by the author inheriting from the Qt \texttt{QTableView} class. \texttt{MyQTableView} reimplements the \texttt{resizeEvent} to make sure the user has the best GUI experience. This new class allows for manual resizing of each column as well as automatic resizing when the widow size changes. Also, there is a button that allows the user to fit the table in the available space by giving all the columns the same width.
\item \textbf{Delegate}: \texttt{PasswordItemDelegate}, a class written by the author inheriting from the Qt \texttt{QStyledItemDelegate} class. It is used to implement the show/hide password functionality.
\end{itemize}

There is one element not mentioned in the model/View architecture: the \textbf{Proxy Model}. It will be explained in details in the filters section. The \textbf{delegate} will be explained in the Show Password section.

In listing \ref{lis:modelview} the model view architecture is implemented. Model, Proxy Model and Delegate are interconnected among them, with the database table and with the GUI's table view. Additionally some display tweaks are made, for instance the ID column, vertical header and passwords are hidden.



When it is necessary to change the table to be displayed, either because the user changes walllet or table, or deletes one, the listing \ref{lis:updatemv} is used. Only the \textbf{model} needs to be updated, because it is the one connected to the data. The table view geometry needs to be saved and restored, because with the data change, the columns are automatically resized by Qt to fit the new data, which is visually annoying for the user.

\begin{lstlisting}[style=customc, float=htb, caption={update the model/view}, label = {lis:updatemv}]
save_table_geometry;//each column width
model->setTable(tableName);
model->select();
    
restore_table_geometry;
ui->tableView->setColumnHidden(IDENT_COL, true);//required
\end{lstlisting}

\subsubsection*{Show Passwords action}

To show the passwords it is enough to \textsc{not} use a delegate for the correspondent column. Conversely, to hide them again, the delegate is used, as seen in listing \ref{lis:pass}. The delegate \texttt{displayText} method definition is also shown. Its job is to return the bullet character eight times instead of the actual item value.

\begin{lstlisting}[style=customc, float=htb, caption={Show/Hide Passwords}, label = {lis:pass}]
// *** in pasworditemdelegate.cpp ***
PasswordItemDelegate::PasswordItemDelegte(QObject* parent): QStyledItemDelegate(parent){}
//inherits from QStyledItemDelegate

QString PasswordItemDelegate::displayText
  (const QVariant &value, const QLocale &locale) const {
    return (QString("%1").arg(QChar(0x2022)).repeated(8));
} // just returns the bullet character 8 times

// *** in mainwindow.cpp ***
void MainWindow::on_action_Show_Passwords_toggled(bool show){

	passDelegate=new PasswordItemDelegate(this);
	if (!show)//do not show passwords: use passDelegate
	  ui->tableView->setItemDelegatForColumn(
	    PASS_COL, passDelegate);
	 
	else{ //show passwords: do not use delegate
	  QMessageBox::StandardButton reply;
	  reply = QMessageBox::question(
	            this,
	            "Passwords",
	            "Are you sure you want to show your passwords",
	            QMessageBox::Yes|QMessageBox::No);
	  if (reply == QMessageBox::No)
	    return;//if error or cancel, do nothing
	
	  ui->tableView->setItemDelegateForColumn(PASS_COL, 0);
	}
}
\end{lstlisting}

\subsubsection*{Filters}
The filters implementation comprise two classes. The first one is related to the GUI, and its job is to align each of the filters with its corresponding table column. The second class is related to the data filtering per se.

The \textbf{filters alignment} is based on the \texttt{ColumnAlignedLayout} class by sashoalm \cite{aligned}. This class is a Layout that inherits from the \texttt{QHBoxLayout} Qt class. It reimplements the \texttt{setGeometry} method to reposition each of the elements in the layout to follow the correspondent column in the tableView that is being tracked. This implementation allows to add any type of widget to the layout, as long as the number of widgets equals the number of tracked columns. The class definition is shown in listing \ref{lis:aligned}.

\begin{lstlisting}[style=customc, float=htb, caption={Aligned Filters definition}, label = {lis:aligned}]
// *** filtersaligned.cpp ***
FiltersAligned::FiltersAligned(QWidget *parent) //constructor
: QHBoxLayout(parent){//inherits from horizontal Box Layout
  add_filters_to_layout; //add filters (most of them QLineEdits)
}
void FiltersAligned::setTableColumnsToTrack(QHeaderView *view) {
    headerView = view; //set tracked tableView
}
void FiltersAligned::setGeometry(const QRect &r){
  QHBoxLayout::setGeometry(r);

  int widgetX = parentWidget()->mapToGlobal(QPoint(0, 0)).x();
  int headerX = headerView->mapToGlobal(QPoint(0, 0)).x();
  int delta = headerX - widgetX;

  // repositioning
  for (int ii = 0; ii < headerView->count(); ++ii) {
    int pos = headerView->sectionViewportPosition(ii);
    int size = headerView->sectionSize(ii);
    auto item = itemAt(ii);
    auto r = item->geometry();
    r.setLeft(pos + delta);
    r.setWidth(size);
    item->setGeometry(r);
  }
}
\end{lstlisting}

To connect the aligned layout to the table view, the listing \ref{lis:alignedcon} is used. In it, an aligned filter object is created and is set as the Layout of a widget positioned over the tableView in the GUI. Then the aligned filter is set to track the tableView's \texttt{horizontalHeader}. Finally any geometry change in the \texttt{horizontalHeader}, or in the \texttt{horizontalScrollBar} calls the \textsc{slot} \texttt{invalidateAlignedLayout}, which in turns calls the \texttt{invalidate} method. This method resets the Layout's cached information, which forces a call to \texttt{setGeometry}. This ensures any resizing of the table's columns is reflected in the filters position.


\begin{lstlisting}[style=customc, float=htb, caption={Table View and aligned filters connection}, label = {lis:alignedcon}]
// *** in mainwindow.cpp when the tableView is created:
  filters = new FiltersAligned();
  ui->filtersWidget->setLayout(filters);
  filters->setTableColumnsToTrack(
    ui->tableView->horizontalHeader());
  filters->setParent(ui->filtersWidget);
  
  connect(ui->tableView->horizontalHeader(),
          SIGNAL(sectionResized(int,int,int)), 
          SLOT(invalidateAlignedLayout()));
  connect(ui->tableView->horizontalScrollBar(), 
          SIGNAL(valueChanged(int)),
          SLOT(invalidateAlignedLayout()));

//the SLOT
void MainWindow::invalidateAlignedLayout(){
    filters->invalidate(); 
}//clears the cache, which forces a call to setGeometry
\end{lstlisting}


The \textbf{data filtering} is done using a custom \texttt{SortFilterProxyModel}. For all the columns except the date, a simple case insensitive match is enough. For the date, using a button in the GUI, the user can choose among two options:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Exact Match filter: }In this configuration, the user enters the exact date they are looking for, using a \texttt{QDateEdit} input element.
\item \textbf{Older Than filter: }Because this is a password wallet, looking for an exact date may not be very useful. Instead, knowing which passwords are older than a given amount of time, and have therefore expired is more helpful. For instance the user could be interested in updating their passwords each six months, so with this filter they can show only those passwords that need to be changed. In figure \ref{fig:filterdate} an Older Than six months filter is shown (as of July the 13th 2018).
\end{itemize}

\begin{figure}[ht]
  \centering
  \subfloat[No filter\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/filterdatea.png}}
  {}
  \subfloat[Older Than 6 Months\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/filterdateb.png}}
  \caption{Date Older Than filter }
 \label{fig:filterdate}
\end{figure}

The filters implementation is very simple. It involves the reimplementation of the \texttt{filterAcceptsRow} method in the ProxyModel as in listings \ref{lis:filterReg}. This method  is called each time the user changes one of the filters contents. The filters work concurrently, so the user can search in multiple columns at the same time. All of them except the date one accept \texttt{RegExp}, so a search like \texttt{google|gmail} is possible. The password filter is only enabled when the passwords are visible.


\begin{lstlisting}[style=customc, float=htb, caption={Filters implementation}, label = {lis:filterReg}]
bool MySortFilterProxyModel::filterAcceptsRow
(int sourceRow, const QModelIndex &sourceParent) const
{
  QModelIndex userIndex = 
    sourceModel()->index(sourceRow, USER_COL, sourceParent);
  QModelIndex domainIndex = 
    sourceModel()->index(sourceRow, DOM_COL, sourceParent);
  QModelIndex passIndex = 
    sourceModel()->index(sourceRow, PASS_COL, sourceParent);
  QModelIndex descIndex = 
    sourceModel()->index(sourceRow, DESC_COL, sourceParent);

  QModelIndex dateIndex = 
    sourceModel()->index(sourceRow, DATE_COL, sourceParent);
  QDate thisDate = QDate::fromString(
    sourceModel()->data(dateIndex).toString(),format);

  return (//only return rows where the conditions are met    
    sourceModel()->
      data(userIndex).toString().contains(userRegExp)         && 
    sourceModel()->
      data(domainIndex).toString().contains(domainRegExp)     && 
    sourceModel()->
      data(passIndex).toString().contains(passRegExp)         &&
    sourceModel()->
      data(descIndex).toString().contains(descRegExp)         &&
    (thisDate<=filterDate_older||!filterDate_older.isValid()) &&
    (thisDate==filterDate_exact||!filterDate_exact.isValid()) &&
  );
}
\end{lstlisting}

\subsection{Entries actions}

In this section, the implementation of the actions add/edit/delete entry are explained.

\subsubsection*{Add Entry action}

The \texttt{AddEntry} class allows users to input a new entry to one of the tables, using the subwindow in figure \ref{fig:addentry}

\begin{figure}[ht]
  \centering
  \subfloat[Passwords are shown and do not match\label{fig:addentrya}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntrya.png}}
  {}
  \subfloat[Passwords are shown and do match\label{fig:addentryb}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntryb.png}}
  {}
  \subfloat[Passwords are shown. zxcvbn library has not been compiled\label{fig:addentryc}]{\includegraphics[width=0.32\textwidth]{chapters/figures/development/addEntryc.png}}
  \caption{Add Entry subwindow}
 \label{fig:addentry}
\end{figure}

This subwindow is composed of:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Text input elements: }To enter the Username, Domain, Description and Password, five \texttt{QLineEdit} are used. The password needs to be entered twice to make sure is the desired one, and if it is not the same in both text fields, an error message is displayed. The date is not entered by the user, but generated automatically based on the system clock.
\item \textbf{Show password checkBox: }By changing the echo mode in the password \texttt{QLineEdit}, it can be hidden or shown. It is hidden by default
\item \textbf{Password Generator Button: }This triggers one of two available generators: PwGen or PassPhraseGen. These are explained in detail in sections \ref{sec:pwgen} and \ref{sec:ppgen}
\item \textbf{l33t buttons: }To increase the password strength the user can translate it to l33t. If they are not happy with the result, a button to reverse the action is also present. The l33t implementation is explained in section \ref{sec:l33t}
\item \textbf{Password Strength elements: } A Progress Bar used to display the password strength calculated with the zxcvbn library, a label to show some information about the strength, and a button to open a subwindow showing the details of these calculations. If the zxcvbn library has not been compiled by the user in the settings window, these elements are disabled. The zxcvbn library is explained in details in section  \ref{sec:zxcvbnim}
\item \textbf{Bottom buttons: }The \texttt{ok} button is only functional when all the text fields (except for \texttt{description}, which is optional) are filled, and the two passwords coincide. The \texttt{settings} button opens the settings subwindow so the user can customize the password generators or the strength estimator without having to close the \texttt{AddEntry} subwindow.

\end{itemize}

When the user clicks the \texttt{ok} button, the new entry needs to be added to the database. Instead of using SQLite commands, it is easier to rely in the high-abstraction level methods offered by the \texttt{model}, as seen in listing \ref{lis:addtomodel}.


\begin{lstlisting}[style=customc, float=htb, caption={Add entry to database using model}, label = {lis:addtomodel}]
AddEntry *add = new AddEntry(this);
add->exec(); //exec AddEntry subwindow
if(add->result()==QDialog::Rejected)
  return; // Error or cancel, do nothing

QSqlRecord rec = model->record(); // Temp entry
rec.setGenerated("id", false); // is managed by SQLite

//Get the values entered by user in AddEntry subwindow
rec.setValue("Username"   , add->getUser());
rec.setValue("Password"   , add->getPassword());
rec.setValue("Domain"     , add->getDomain());
rec.setValue("Description", add->getDescription());

rec.setValue("Date",        QDate::currentDate());//sys clock

int newRecNo = model->rowCount(); //insert at the end of table
if (!model->insertRecord(newRecNo, rec))
  return;
model->submitAll();// if insert ok, submit changes.
\end{lstlisting}

\subsubsection*{Edit Entry action}

The user can edit any of the entries by selecting one of the cells in the \texttt{tableView} and clicking the \texttt{Edit Entry} button, or by double-clicking any of the cells. In either case, the data from the selected row is retrieved and passed to new \texttt{AddEntry} object using its constructor. In this way, the user is presented with an \texttt{AddEntry} subwindow where the input fields are already filled with the current data. The user can then modify and save them by clicking \textsc{ok}. In this process the \texttt{ProxyModel} is used instead of the \texttt{model}, because the former allows to identify the items selected in the \texttt{tableView}.

\subsubsection*{Delete Entry action}

Deleting an entry is very simple. The row index of the selected cell is used in the \texttt{ProxyModel} method \texttt{removeRow(row)}, and the change is submitted with \texttt{submitAll}. Before deleting, the user is asked to confirm the action.

\subsection{Other functionalities}
In this section, a set of miscellaneous functionalities are explained.

\subsubsection*{Launch Domain action}

Using the Qt function \texttt{QDesktopServices::openUrl(QUrl(domain))}, it is straight forward to open the domain of the entry selected by the user. It will be opened in the default web browser configured in the OS. The only detail to play attention is the format. If the domain entered by the user does not start with \texttt{http://} or \texttt{https://}, then \texttt{http://} is prepended. Also, if the entered domain does not contain any dots apart from the one in \texttt{www.}, then the most common top-level domain, \texttt{.com} is added. This will not work in all the cases, but should help fixing some of the domains when the user forgets to type the TLD.


\subsubsection*{Status Bar}
The status bar, at the bottom of the main window, is used to display three types of information:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{Wallet Name: }The wallet name (with full path) is permanently displayed at the right side of the status bar in color blue. In case the wallet does not have a name because the user has not saved yet, \texttt{unnamed} is displayed. When the wallet has unsaved changes, an asterisk is added to the end resulting in: \texttt{/absolute\_path/wallet\_name*} 

\item \textbf{Success: }After any save/open/delete operation, a black message is shown for two seconds in the left side of the status bar, informing the user the process concluded without issues.

\item \textbf{Error/Warning: }In the eventuality of an error or warning during the execution of a command, for instance, if it is not possible to load the SQLite driver, a red message in the left side of the status bar informs the user about the issue.
\end{itemize}


\subsubsection*{Preferences Subwindow}

This subwindow is accessible from the \texttt{Menu Bar} and from the \texttt{AddEntry} subwindow. It allows to customize the password generators and the strength estimator. Their available configurations are covered in their respective sections. 

\subsubsection*{Environment subwindow}

From the environment subwindow the user can select which of the keys and algorithms present in the SEcube™ chip to use for the encryption/decryption process. 

Keys are used to divide wallets into categories (work, banking, social) and allow their sharing.  A given user can have for instance one key that is shared among co-workers, so all of them can access work-related passwords using their respective SEcube™ devices. Similarly, other key can be shared with their family to access banking accounts passwords, and finally have a personal key that is not shared with anyone and is used to encrypt social media passwords. 

The current SEcube™ firmware version only includes one algorithm for the data encryption/decryption process, but in the future it may provide more than one. Different algorithms offer different security characteristics that some advance user may find useful. For example one user could be concerned about some specific type of attack that requires an special algorithm, or regard one algorithm superior over the others. 

Figure \ref{fig:envi} depicts the environment subwindow.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.5\columnwidth]{chapters/figures/development/envi.png}}
  \caption{Environment subwindow}
  \label{fig:envi}
\end{figure}


\subsubsection*{Help Subwindow}

This subwindow teaches the user a few tips about how to use the application features, some of which may not be obvious, like the strength estimator or the date filter. It also  gives some information about the application, like the author, year, and code sources.



\subsubsection*{l33t} \label{sec:l33t}

This is a very simple converter that uses the capabilities of the \texttt{QString} class to replace each occurrence of the letters \texttt{o i z E A s b T B P} with the numbers \texttt{0 1 2 3 4 5 6 7 8 9} respectively, and the letter \texttt{l} with the character \texttt{|}. To un-l33t, the reverse process is made. It is worth noticing that password crackers (and strength estimators like zxcvbn) usually try an l33t dictionary too, so this option may increase the password strength, but not by too much. In table \ref{tab:l33t} a few passwords and their l33t version are compared. The strength measured with zxcvbn is reported.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{A few l33t examples}
\begin{tabular}{lr}
\toprule
\textbf{Password} & \textbf{Log Entropy (Level)} \\ \midrule

LeytonVariational & 9.44 (Level 3) \\
Leyt0nVar1at10na| & 10.22 (Level 4) \\
\midrule
PenicuikCiting & 9.09 (Level 3) \\
9en1cu1kC1t1ng & 13.87 (Level 4) \\
\midrule
LauraDrogheda & 6.44 (Level 3) \\
LauraDr0gheda & 6.74 (Level 4) \\

\bottomrule
\end{tabular}
\label{tab:l33t}
\end{table}

\subsection{PwGen: Pronounceable Passwords Generator} \label{sec:pwgen}
As seen from previous sections, the PwGen program is open source and available in the official Linux repositories. A very simple way of including its functionalities into the SEcubeWallet application would be to use a \texttt{Qprocess} to call PwGen as an external program. Although is tempting to use this solution because of its simplicity, there are three drawbacks with this approach:

\begin{enumerate}
\setlength\itemsep{0pt}
\item It would require for the user to install the PwGen program, as it is usually not included in common Linux distributions.
\item It would not be very portable, because even if there is a PwGen version for windows, the available version or input parameters could differ in different platforms.
\item Security could be compromised. As PwGen needs to communicate the generated password back to the SEcubeWallet application, an attacker could steal the password in this process.
\end{enumerate}

For these reasons, it was decided to embed the PwGen sources directly into the application, this ensure the password never leaves the application memory space. 
To include the sources into the application, some slight modifications (mostly simplifications) to the PWGen \texttt{main()} function were necessary. This is because the original sources are intended for the use of PwGen as a independent console program called by users, so the \texttt{main()} contains code dedicated to parse the input arguments in the standard \texttt{argc argv[]} fashion. Only the \texttt{pwgen.c} and \texttt{pwgen.h} --- files where the \texttt{main()} is implemented --- were modified.

\subsubsection*{Options GUI}
As all the options for PwGen besides the password length are yes or no questions, the checkable list shown in figure \ref{fig:pwgenSett} is perfect for this purpose.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/pwgenSett}
  \caption{PwGen settings in the preference window}
  \label{fig:pwgenSett}
\end{figure}

When the \texttt{OK} button is clicked, all the values are saved using the \texttt{QSettings} class, so they are available even after restarting the application.

\subsubsection*{Usage}

When the \texttt{Generate Password} button in the \texttt{AddEntry} class is clicked, the settings values stored in with the \texttt{QSettings} class are read and from them a \texttt{char[]} with the PwGen options syntax is built. Before calling the Generator, it is necessary to allocate a memory space equal to the desired password length (in \texttt{char}) and pass this buffer as a pointer (\texttt{char*}) to PwGen. PwGen will write the generated password in this space. This steps can be seen in the listing \ref{lis:pwgen}


\begin{lstlisting}[style=customc, float=htb, caption={PwGen call inside AddEntry}, label = {lis:pwgen}]
//read user settings (if existent)
if (settings.value("passGens/pwgen/1cap").toBool())
    options.append("c");
if (settings.value("passGens/pwgen/1num").toBool())
    options.append("n");
if (settings.value("passGens/pwgen/1spec").toBool())
    options.append("y");
if (settings.value("passGens/pwgen/noAmb").toBool())
    options.append("B");
if (settings.value("passGens/pwgen/noCap").toBool())
    options.append("A");
if (settings.value("passGens/pwgen/noNum").toBool())
    options.append("0");
if (settings.value("passGens/pwgen/noVow").toBool())
    options.append("v");
if (settings.value("passGens/pwgen/random").toBool())
    options.append("s");

//check if user entered an integer, if not, default is 16
if(settings.value("passGens/pwgen/len").toInt())
    length = settings.value("passGens/pwgen/len").toInt();

//allocate space for password
buf = (char*)malloc(length+1);
if(!buf){
  return;//error, could not allocate
}
//actual call to password generator
main_pwgen(
  options.length(),               //int, number of options 
  options.toLatin1().constData(), //char *, options 
  length,                         //password length 
  buf                             //char *, to return the password           
);
genPass = QString::fromLatin1(buf,length);
free(buf);
\end{lstlisting}

\subsubsection*{Results}

A few examples of the resulting Passwords are show in table \ref{tab:pwgenExm}, with their respective zxcvbn Log entropy score and Level. As expected, the passwords with highest entropy are those obtained using the \texttt{-s} (Random) and \texttt{-sy} (Random and especial characters) options. Even with only 6 characters it is possible to get a Level 4 password like \texttt{TBw4)9}. The drawback is, they are hard to remember and type. 

On the contrary, a password obtained with the \texttt{-BA0} (No ambiguous, do not capitalize, no numbers, pronounceable) options, like \texttt{nofosootei}, only reaches a Level2, but it is very easy to remember and type.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{A few PwGen generated passwords}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{4cm}ccr
@{}}
\toprule
\hd{Password} & \hd{Length} & \hd{Options} & \hd{Log Entropy \\ \& Level}  \\ \midrule

iesohGhai3   & 10 & -   &  9.75 (Level 3)\\
ees0cooLo2   & 10 & -   & 10.47 (Level 4)\\
dX042wKqlW   & 10 & s   & 17.86 (Level 4)\\
@!,Q*l5\}+H  & 10 & ys  & 18.15 (Level 4)\\
TBw4)9       &  6 & ys  & 11.62 (Level 4)\\
B7t34Lck     &  8 & v   & 11.87 (Level 4)\\
nofosootei   & 10 & BA0 &  6.50 (Level 2)\\
\bottomrule  
\end{tabular*}
\label{tab:pwgenExm}
\end{table}

\subsection{zxcvbn Password strength estimator} \label{sec:zxcvbnim}

The original zxcvbn project, developed in CoffeeScript became so popular it was ported to a large variety of languages. In this work the C/C++ version available at \cite{zxgit} was used. The files used in this project are:

\begin{itemize}
\setlength\itemsep{-3pt}

\item \textbf{zxcvbn.c} Main source file
\item \textbf{zxcvbn.h} Main header file
\item \textbf{dict-generate.cpp} Used for generating the dictionary sources
\item \textbf{Makefile} To compile the dictionary generator and main program.
\item \textbf{words-*.txt} A few examples of dictionary files in plain text format.
\end{itemize}

Besides source files, zxcvbn also needs to compile the dictionary files, but first lets define what is a dictionary, why are they important and why they need to be compiled (For general dictionaries only. User dictionaries are small and can be added at runtime).

\subsubsection*{General dictionaries}

Dictionaries are a crucial part of the algorithm, because they are used estimate the security level of a password according to how common the used words (if any) are. A password containing words present in any of the dictionaries will be easier to crack as hackers will probably try out those specific words or a combination of them.

General dictionaries contain a large number of words that are useful for all users. Examples of these type of dictionaries (included in this work) are:
\begin{itemize}
\setlength\itemsep{-3pt}

\item 100000 English words from wikipedia.
\item 88800 Last names from the US census database
\item 39000 English words from tv and film from the wikiproject \cite{wiktionary}
\item 47000 Most common passwords from Burnett \cite{burnett}
\item 15480 Italian words from the \textsc{badip} project \cite{badip} 
%TODO
\todo{More dicts, see bookmarks}
\item 4276 Female names from the US census database 
\item 1220 Male names from the US census database
\end{itemize} 

As the dictionary files in plain text are pretty large, the algorithm does not read from them directly. Instead, a \texttt{DicNodes} array is generated, using the tool \texttt{dict-generate}, and this array is compiled into the source code.
To add their own dictionaries, the users need to make sure they are saved as plain-text, (.txt UTF-8), and stored into the zxcvbn directory. The files must have one word per line, with the first word being the most common one. So for instance, in the English dictionary the first word is \texttt{the} and the last one is \texttt{surma}. This is important as it is used to calculate the entropy of the passwords. A password containing the word \texttt{surma} is far more secure that one containing the word \texttt{the}.

\subsubsection*{Static Library vs Shared Library}

Because the dictionaries are transformed into a source file and then compiled together with the main program, it is not possible to add, remove or modify dictionary files after the sources are compiled. Therefore the zxcvbn library can not be embedded into the SEcubeWallet application as a static library (or using the C sources directly), but rather, a \textbf{shared library} approach was followed, which allows the dynamic unload/update/load of the library. This has some performance penalties over static libraries, but it is the only way to give the users the possibility of customize the dictionaries as they please.

\subsubsection*{Compilation process}

The steps performed by the \texttt{makefile} in order to compile the dictionaries and sources are:

\begin{enumerate}
\setlength\itemsep{-3pt}

\item Compile the source file \texttt{dict-generate.cpp} to obtain the dict generator executable\texttt{dictgen}.
\item Execute \texttt{dictgen} with the names of dictionaries to process as input argument. As a result the file \texttt{dict-src.h} is created.
\item Compile the files \texttt{zxcvbn.c} and \texttt{zxcvbn.h} together with the just generated \texttt{dict-src.h}, using the gcc flag \texttt{-fPIC} so the resulting object file \texttt{zxcvbn-inline-pic.o} is suitable for library inclusion.
\item Generate the shared library \texttt{libzxcvbn.so} from the object file. This is the library used by the SEcubeWallet sources.
\end{enumerate}

The compilation process can be started by the user from the preference window, where they can also select the dictionaries to use, or clean the generated files. The compiling is made with OS calls, through the use of \texttt{QProcess}. To avoid the application from crashing or getting stuck, the \texttt{Qprocess} has a timeout. As the compile process may take a while depending on the dictionaries size, this timeout can be configured by the user. In figure \ref{fig:zxcvbnGen} the GUI for these actions is shown.

\begin{figure}[ht]
  \centering
  \subfloat[Tab dedicated to zxcvbn preferences]{\includegraphics[width=0.5\textwidth]{chapters/figures/development/zxcvbnGen.png}}
  \subfloat[Checkable dialogue to enable dictionaries, appears after clicking the Choose button]{\includegraphics[width=0.4\textwidth]{chapters/figures/development/dictListSett.png}}
  \caption{zxcvbn general dictionaries configuration}
 \label{fig:zxcvbnGen}
\end{figure}

\subsubsection*{Dynamic Library loading}

To manage the zxcvbn shared library at runtime it is possible to use the qt class \texttt{Qlibrary}, which provides access to the functionality in the library in a platform independent way. To use it, is necessary to pass as argument to the constructor the path to the library. Then load it and resolve the desired functions. If no errors are found, the functions can be used as usual. Finally unload the library when it is not needed any more. See Listing \ref{lis:qlibrary}.


\begin{lstlisting}[style=customc, float=htb, caption={Qlibrary basic usage}, label = {lis:qlibrary}]

/***** In header file *****/
//Main zxcvbn function type
typedef double (*ZxcvbnMatch_type)(const char *Passwd, 
                                   const char *UserDict[], 
                                   ZxcMatch_t **Info );
//Function used to free the Info structure
typedef void (*ZxcvbnFreeInfo_type)(ZxcMatch_t *Info);

QLibrary * zxcvbnLib = 0;
ZxcvbnMatch_type ZxcvbnMatch = 0;
ZxcvbnFreeInfo_type ZxcvbnFreeInfo = 0;

/***** In cpp file *****/     
zxcvbnLib = new QLibrary(zxcvbn_lib_path);
    
if(zxcvbnLib->load()){
  ZxcvbnMatch = (ZxcvbnMatch_type) zxcvbnLib->resolve("ZxcvbnMatch");
  ZxcvbnFreeInfo =(ZxcvbnFreeInfo_type) zxcvbnLib->resolve("ZxcvbnFreeInfo");
}

if (!ZxcvbnMatch || !ZxcvbnFreeInfo ){
  //error: Any of the two functions was not resolved correctly
else{
  //we can use the functions normally
  
//When not needed any more
zxcvbnLib->unload();
ZxcvbnMatch = 0;
ZxcvbnFreeInfo = 0;
free(zxcvbnLib);  
  
\end{lstlisting}


\subsubsection*{User Dictionaries}

The user dictionary contain words that are relevant only to a specific user. For example, if the application is used to increase the strength level of passwords used by employees in a company, adding the company's name to the dictionary is a good idea. Furthermore, if the company works in the automotive business, related words as motor, aerodynamic, wheels etc. should be added. By adding those words to the user dictionary, the strength level of passwords using them will decrease, and so the user will be encouraged to never use words that are too easy to guess. The key to a good password is in its randomness. When a hacker is trying to crack one, they will for sure try words relevant to the target.

From the GUI the user can add words manually, or can load them from a text file, but as the words are saved as a simple array, the text file size should not be too large. For large files, it is better to add them as General dictionaries.

\subsubsection*{Estimator Usage}

After the library is loaded and the functions resolved, to use the estimator one simply needs to call the main function \texttt{ZxcvbnMatch} whose declaration we see in Listing \ref{lis:zxcvbn} 

\begin{lstlisting}[style=customc, float=htb, caption={ZxcvbnMatch function declaration}, label = {lis:zxcvbn}]
double ZxcvbnMatch(       //Returns: entropy value in bits.
 
  const char *Passwd,     //The password to be tested. Null terminated string. 
  
  const char *UserDict[], //User supplied dictionary words to be considered particulary bad. Passed as a pointer to array of string pointers, with null last entry (like the argv parameter to main()). May be null or point to empty array when there are no user dictionary words. 
  
  ZxcMatch_t **Info       //The address of a pointer variable to receive information on the parts of the password. This parameter can be null if no information is wanted. The data should be freed by calling ZxcvbnFreeInfo().
);
\end{lstlisting}

To obtain the password strength level, it is necessary to compare the \texttt{zxcvbnMatch} return value (The entropy in bits) as seen in section \ref{sec:zxLevels}. The strength level is shown to the user with a progress bar.
%TODO
\todo{talk about models and table}
To the user may be more relevant to see some estimates about how long it would take for an attacker to crack the password. This information can be obtained from the entropy, assuming some numbers for the attempts/time the attacker can perform. These results are shown in a table like the one in figure \ref{fig:zxcvbnTimes}
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=1\columnwidth]{chapters/figures/development/zxcvbnTimes}
  \caption{Crack times for different attacker capabilities}
  \label{fig:zxcvbnTimes}
\end{figure}

Some interesting additional information can be obtained from \texttt{ZxcMatch\_t ** Info}. By traversing the data in this pointer, it is possible to see how the zxcvbn algorithm broke down the password. The user can see this information in a table like the one in figure \ref{fig:zxcvbnBreak}
\begin{figure}[htb]    
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.9\columnwidth]{chapters/figures/development/zxcvbnBreak}
  \caption{Password broke down by the zxcvbn algorithm}
  \label{fig:zxcvbnBreak}
\end{figure}



\subsection{PassPhrase Generator} \label{sec:ppgen}

The \texttt{PassPhraseGen} C++ function implements the PassPhrase Generator. The function call is done from the \texttt{AddEntry} class, when the \texttt{Generate Password} button is clicked.

\texttt{AddEntry} reads the configuration values stored as \texttt{QSettings}, asserts them and then makes the call. This values can be modified by the user in the preferences window, shown in figure \ref{fig:ppgenSett}. After the user selects the dictionaries and tunes the available options, they must click the apply button, which will trigger a line by line read of the dictionaries, to count the number of lines, that is the number of words available. This is necessary as it is not possible to know how many lines a file has without counting them, and the total number is required in order to generate properly bounded random numbers in the PassPhraseGen function.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/ppgenSett.png}
  \caption{Settings for PassPhrase Generator}
  \label{fig:ppgenSett}
\end{figure}

The function declaration is shown in listings \ref{lis:ppgen}


\begin{lstlisting}[style=customc, float=htb, caption={PassPhraseGen function declaration}, label = {lis:ppgen}]
QString PassPhraseGen(  //Return: Generated PassPhrase
  QString path,         //path to dicts
  QStringList dicts,    //list of dicts
  QStringList dictsLen, //cumulative list of dics lengths
  int totalLen,         //total number of candidate words
  int numWords,         //number of words in the password
  bool ppgenMinLenEnab, //use only words longer than min len
  int ppgenMinLen,      //min length
  bool capFirst,        //uppercase first letter of each word
  bool ppgenLowerEnab,  //use only lower part of dicts
  int ppgenLower        //how much of the lower part to use
);
\end{lstlisting}

The function first generates \texttt{numWords} random numbers in the range \texttt{[1, totalLen]} with the Qt function \texttt{QRandomGenerator} (introduced in version 5.10). The generated numbers represent \textsl{Line numbers} in the dictionary files. As each line contains a word, the function indeed extracts random words. There are a few things to consider in this process:
\begin{enumerate}
\setlength\itemsep{-3pt}

\item It is impossible to read a random line from a TextFile without reading all the previous lines first. So, in order to extract the words it is necessary to read the dictionary line by line and keep a counter to know the number line we are at. To speed up the process making sure each line is read only once, the random numbers are sorted in ascending order first. The dictionary can then be read line by line extracting the words where the counter equals one of the random numbers. When the last random line is extracted, the file can be closed.

\item There can be multiple dictionaries. The generated random numbers span the total of available words, so some random lines will be in some dictionaries, some in others. Therefore, using the \texttt{dictsLen} list, which contains the cumulative lengths of the dictionaries, we need to determine in which dictionary and in which internal line, each random number is. With this information, and the random numbers ordered, it is possible to extract the words efficiently and making sure dictionary files are opened only if necessary and only once.

\item When the minimum length option is enabled, the total number of available words is reduced. The algorithm accounts for this fact by counting only the lines with a word larger than the minimum length. This is done both in the preference window, where the total number of lines is counted, and at the word extraction process. In this way, the random lines are pinpointed as before, by reading line by line and comparing the counter; the working logic is not altered, it just ignores the "disabled" short lines.

\item Finally, to consider only the lower part of each dictionary the preferences window counting process is not altered, and the modifications are all done at the extraction process. If for example, the user wants to work with the lower 30\%, the random generated numbers are now bounded to \texttt{[1,  (0.3)totalLen]}. The corresponding dictionary and internal line for each random number are calculated by taking into account that the first 70\% of each dictionary must be skipped. With this two values, the files can be read as in the simple case. As this process is different from the minimum length one, they do not interfere with each other.

\end{enumerate}

Table \ref{tab:ppgenExm} presents some PassPhrases examples for different configurations, along side the score given by the zxcvbn estimator. The estimator uses the same dictionaries as the generator, so this assumes a worst case scenario where the hacker has access to all the possible words the user considered when creating the PassPhrase.

Two dictionaries where used: \texttt{words-eng\_wiki.txt} with 100000 lines and \texttt{words-it\_badip.txt} with 15480 lines (around 6 times smaller), so most of the extracted words will be English.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{PassPhrases examples for different configurations}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{6.5cm}cccr
@{}}
\toprule
\hd{PassPhrase} & \hd{No. of \\ words} & \hd{Min.\\word \\ Len} & \hd{\% of \\ dict.\\ used } &\hd{Log \\ Entropy \\ \& Level}\\ \midrule

		 Cocchio & 1 & - & - & 4.27 (L1) \\ 
		 Melun   & 1 & - & - & 4.93 (L1) \\ 
		 
		 Legitimately & 1 & 8 & - & 4.55 (L1) \\
     
     Woodhaven		& 1 & 8 & 30\% & 4.94 (L1) \\
     \midrule
     VestaOrman    & 2 & - & - & 7.78 (L2) \\    
     ShorelineCech & 2 & - & - & 9.18 (L3) \\
     
     MongoliaSimpsons & 2 & 8 & -    & 7.30 (L2) \\
     McinnisPhaya     & 2 & - & 30\% & 9.14 (L3) \\

     ZucchiniSalamandra & 2 & 8 & 30\% & 9.19 (L3) \\
     SacchettiVigevano  & 2 & 8 & 30\% & 9.11 (L3) \\

     DrammaturgicoSbatacchiare  & 2 & 12 & - & 8.98 (L3) \\
     MalformationsAstrophysical & 2 & 12 & - & 9.60 (L3) \\
     \midrule
     LatinaInterchangeFbo & 3 & - & - & 13.5  (L4) \\
     OsaAymanCantinflas   & 3 & - & - & 12.98 (L4) \\
     ImmobileCwSites      & 3 & - & - & 11.43 (L4) \\
     
     RimmelBragFaenza     & 3 & - & 30\% & 13.49 (L4) \\
     
     RecliningCanberraEcuadorian         & 3 & 8 &  -   & 13.69 (L4) \\
     
     
     SeashellsHippocraticCameroun        & 3 & 8 & 30\% & 14.90 (L4) \\
     InaspettatoRothschildsDisconcerting & 3 & 8 & 30\% & 14.48 (L4) \\
\bottomrule
\end{tabular*}
		\label{tab:ppgenExm}
\end{table}

The results in the table indicate the most important parameter is the number of words. Three words are enough to reach a zxcvbn level 4, which, as seen in previous sections, is very secure. A two word PassPhrase as long as \texttt{DrammaturgicoSbatacchiare} is not better than the shorter \texttt{ImmobileCwSites}, because the latter has one more word. The minimum word length also influences the PassPhrase entropy, but their effects are not as pronounced. Finally, working only with to the lower part of the dictionary may seem to not have any effect, but in reality its use is crucial: it ensures the generated PassPhrases do not contain any of the most common words, like \texttt{the} or \texttt{essere}. From the results on the table we can not appreciate this fact, but at least we learn the option does not do any harm either. (Although if the attacker finds out the user is generating PassPhrases using only the 30\% most uncommon words on a given language, their job would get easier).


\subsection{The FAT32 bug} \label{sec:fat32bug}
During the application development a strange and elusive bug was found: The \texttt{secureSQLite} library did not work properly with the FAT32 file system. When the save directory was in a FAT32 system, (either a partition, an external hard disk or an USB stick), the created databases were not stored properly, and when trying to open them they were completely empty. Only the database name was saved; any table in the wallet was lost. Moreover, after saving, besides the \texttt{.sqlite} file, a \texttt{.sqlite-journal} was created. Figure \ref{fig:fat32} depicts the presences of this file in a FAT32 file system.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.55\columnwidth]{chapters/figures/development/fat32.png}}
  \caption{secureSQLite Databases in a FAT32 file system}
  \label{fig:fat32}
\end{figure}

This file is known as a rollback journal and is used by the SQLite standard to avoid database corruption when a transaction can not be completed. From the SQLite official documentation \cite{journal}:
``The rollback journal is always located in the same directory as the database file and has the same name as the database file except with the 8 characters "-journal" appended. The rollback journal is usually created when a transaction is first started and is usually deleted when a transaction commits or rolls back. The rollback journal file is essential for implementing the atomic commit and rollback capabilities of SQLite. Without a rollback journal, SQLite would be unable to rollback an incomplete transaction, and if a crash or power loss occurred in the middle of a transaction the entire database would likely go corrupt without a rollback journal.
The rollback journal is usually created and destroyed at the start and end of a transaction, respectively. But there are exceptions to this rule.
If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a "hot journal" in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction.''

The presence of the journal file hints at the problem being an interruption during the execution of \texttt{secureSQLite} write functions when working on a FAT32 system. A few test were performed to try to narrow down the error origin:

\begin{itemize}
\setlength\itemsep{-3pt}

\item The application was tested in other computer running a different OS, and the problem persisted, always in FAT32 systems, meaning it was not an OS specific issue.
\item The application \texttt{secureSQLiteBrowser} which also uses the secureSQLite library was tested and presented the same problem, meaning it was not an error in the library usage.
\item The demo applications \texttt{SEfile\_IMG}  and \texttt{SEfile\_TXT} were also tested, and worked without any problems in FAT32 partitions. These applications do not use \texttt{secureSQLite}; they leverage directly the \texttt{SEfile} library, which is also used by the \texttt{secureSQLite} library, meaning the problem was not in \texttt{SEfile} but in \texttt{secureSQLite}. This was proved to be a wrong assumption later on.
\end{itemize}

With these points in mind, the bug was searched inside the \texttt{secureSQLite} library, but after several debug sessions, it was possible to trace the error origin to the \texttt{SEfile} library. Specifically, in the file \texttt{SEfile.c}, and function \texttt{secure\_seek}. Figure \ref{fig:traceback} shows the actual traceback, from the call to \texttt{sqlite3\_exec} in the \texttt{Save\_Wallet} action, all the way up to the \texttt{secure\_seek} function.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.8\columnwidth]{chapters/figures/development/traceback.png}}
  \caption{Error Traceback}
  \label{fig:traceback}
\end{figure}

The actual error is produced in the call to the OS function \texttt{lseek()} in line \ref{line:error} of listing \ref{lis:secseek}. 
\begin{lstlisting}[style=customc, float=htb, caption={FAT32 Error origin at secure\_seek}, label = {lis:secseek}, escapechar=¬]
/**This function is used to move correctly the file pointer.
 * [in]  hFile     The handle to the file to manipulate.
 * [in]  offset    Amount of character we want to move.
 * [out] position  Pointer to int32_t to store the final pos.
 * [in]  whence    Move from file start, end or current pos.
 * [return]        Returns '0' in case of success.*/
uint16_t secure_seek(SEFILE_FHANDLE *hFile, int32_t offset, int32_t *position, uint8_t whence){
  ...  
  buffer_size = *position - file_length;
  if(buffer_size>0){ ¬\label{line:buffer}¬
    //if destination exceed the end of file, empty sectors are inserted at the end to keep the file consistency
    buffer=calloc(buffer_size, sizeof(uint8_t));
    if(buffer==NULL)
      return SEFILE_SEEK_ERROR;
    
    if((file_length%SEFILE_LOGIC_DATA)){
      errno = 0; //clear errno 
      hTmp->log_offset=lseek( // the error is produced here ¬\label{line:error}¬
        hTmp->fd, 
        ((file_length%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE), 
        SEEK_END);
      error = errno;//capture errno, 22 when in FAT32 systems
      if(hTmp->log_offset==4294967295)
        //lseek returns (off_t)-1 when error. off_t is 32 bits, so 2^32-1 = 4294967295
        return SEFILE_SEEK_ERROR; //the upcoming secure_write call fails anyway
      
      if(secure_write(&hTmp, buffer, buffer_size)){
        free(buffer);
        return SEFILE_SEEK_ERROR;
      }   
\end{lstlisting}

\vspace{15pt}
The \texttt{lseek()} function, as defined in the linux manual page \cite{lseek}:

\texttt{\textcolor{blue}{off\_t} lseek(\textcolor{blue}{int} fd, \textcolor{blue}{off\_t} offset, \textcolor{blue}{int} whence);}

``\textbf{\texttt{lseek()}} repositions the file offset of the open file description
       associated with the file descriptor \texttt{fd} to the argument \texttt{offset}
       according to the directive \texttt{whence} as follows:
       
       \texttt{SEEK\_SET} The file offset is set to offset bytes.
       
       \texttt{SEEK\_CUR} The file offset is set to its current location plus offset bytes.
       
       \texttt{SEEK\_END} The file offset is set to the size of the file plus offset bytes.
lseek() allows the file offset to be set beyond the end of the file
       (but this does not change the size of the file)
       
\textbf{Return Value:} Upon successful completion, \texttt{lseek()} returns the resulting offset
location as measured in bytes from the beginning of the file.  On error, the value \texttt{(off\_t) -1} is returned and \texttt{errno} is set to indicate the error.''

\vspace{7pt}
\texttt{secure\_seek()} can be seen as a wrapper that uses the OS function \texttt{lseek()} to move the file pointer correctly, taking into account the way the \texttt{SEfile} library redefines a file, including the overhead added by sectors and headers that allow the data to be encrypted.

\vspace{7pt}       
To better understand what was causing the error, the \texttt{return} and \texttt{errno} values for two save operations of the same database were compared. One into a FAT32 file system and the other into a ext4 system.

When the FAT32 system was used, the \texttt{return} value was indeed \texttt{(off\_t)-1}, and the \texttt{errno}, was set to \texttt{22}, which corresponds to:

``\texttt{EINVAL}:  \texttt{whence} is not valid.  Or: the resulting file offset would be negative, or beyond the end of a seekable device.''

When saving into an ext4 file system, the \texttt{return} value was \texttt{9844} and \texttt{errno} was equal to zero.

\vspace{7pt}
Figure \ref{fig:errordebug} shows this difference, and it is worth noticing that besides the file descriptor and pointers (always different for different executions), the rest of the variables have the same value
\begin{figure}[ht]
  \centering
  \subfloat[FAT32 filesystem\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/fat32debug.png}}
  {}
  \subfloat[ext4 filesystem\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/ext4debug.png}}
  \caption{Return and errno values for a save operation}
 \label{fig:errordebug}
\end{figure}

Going back to the \texttt{secure\_seek()} code in listing \ref{lis:secseek}, the line \ref{line:error} moves the file pointer to the last \texttt{LOGIC\_DATA} byte, because in order to keep the file consistency, its is required to write empty sectors starting from this position until the end of the file. To do so, starting from the end of the file (thus the argument \texttt{SEEK\_END}), the function moves the pointer backwards the number of empty bytes in the last sector.

In order to move backwards, the \texttt{offset} argument of \texttt{lseek()} must be negative. In this case, the argument is equal to: 

\lstset{style=customc}
\lstinline"offset = (file_length%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE"

Which should always be always negative, but it turns out, in the case of the FAT32 file system, this offset is not interpreted as a 2's complement negative value, but as a very large positive one. Therefore, the \texttt{lseek()} function tries to move the pointer outside the file limit, explaining the error: \texttt{EINVAL}: the resulting file offset would be negative, or beyond the end of a seekable device.

\vspace{7pt}
To fix the error, a simple cast to \texttt{\textcolor{blue}{int32\_t}} for the \texttt{offset} argument is enough, resulting in the call:
\vspace{5pt}

\lstinline|hTmp->log_offset=lseek(|

\lstinline|  hTmp->fd,| 

\lstinline| (int32_t)((file_lengh%SEFILE_LOGIC_DATA)-SEFILE_SECTOR_SIZE),| 

\lstinline|  SEEK_END);|
\vspace{7pt}

This kind of casting was actually found in other function calls in the \texttt{SEfile.c} file, so it made sense to use it in this situation too.

\vspace{7pt}
The reason the problem only affected FAT32 partitions is probably related to the fact that, as \texttt{lseek()} needs to move a file pointer, low-abstraction level functions need to be used, which are have different implementations for each type of file system. The ext4 low level functions were able to interpret the offset as negative whereas the FAT32 took it as positive.

Why the error only appears when using the \texttt{secureSQLite} library, and not in the demo applications \texttt{SEfile\_IMG} and \texttt{SEfile\_TXT} honestly remains a mystery. It may be  that the condition in line \ref{line:buffer} of listing \ref{lis:secseek} (\lstinline|if(buffer_size>0)|), that evaluates if the destination exceeds the end of file, is only met in rare occasions, and the way SQLite journaling works is one of them.
