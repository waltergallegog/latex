\chapter{Application Development}

%\section{Requirements (and Specifications)}
%TODO
\todo{req and spec}

\section{Useful concepts definition}

More detailed explanations of the following concepts will be given later on, but it is helpful to shortly define them here so this work is more easily readable.

\subsection{Wallet} A password wallet is a digital form of securely keeping passwords and some meta information. In this work, a Wallet is stored as a Sqlite DataBase. A wallet can have as many tables as the user wants. For instance an user could have a table for storing social media passwords, another one for work-related passwords and a last one for credit cards and bank accounts passwords. Finally, Each table has a set of defined fields (Username, Domain, Password, Date, Description).

\subsection{SEcube} SEcube is a custom chip produced by the Blu5 group \cite{Blu5} that integrates an ARM CPU, a FPGA and a SmartCard. The chip is specifically designed for security purposes, allowing developers to implement encryption/decryption functions that are executed fast and are guaranteed to be reliable. The chip can be connected to a PC by USB, Ethernet etc...., so an application running on the PC can use the SEcube to encrypt/decrypt some date.

\subsection{SEcube SDK} The SEcube Open SDK is a set of open libraries designed to make the development of applications using SEcube more convenient. There are two types of Libraries: Host side (PC) and device side (SEcube) libraries. In general host side functions make requests to device side functions and wait for their response. Moreover, Libraries are divided in four and two hierarchical levels of abstraction, for host and device side respectively. Level0 and Level1 are the lowest levels and are present in both host and device. L0 provides the communication protocols while L1 provides basic security APIs.

\subsection{SEfile} 
SEfile is a Level 2 API that allows users to encrypt/decrypt data (files in the hard disk), so they can only be read when the SEcube chip is connected to the PC. When the SEcube is not connected, it is impossible to read the files as the information necessary to decrypt them is physically stored in the SEcube.

\subsection{Sqlite DB}
%TODO
\todo{sqlite}

\section{Design}

The purpose of this section is to give the reader a clear overview of how the application works in general terms. 

A simplified design architecture is displayed in figure \ref{fig:BasicDesign}. It shows which Software Libraries are used by the application and when it uses them.


\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{chapters/figures/development/BasicDesign.pdf}
	\caption{Basic Design: Used Libraries}
	\label{fig:BasicDesign}
\end{figure}

The following is a brief explanation of these Libraries and they usage. More details about each Library and why they were chosen are given in section \ref{sec:lib} and section \ref{sec:imp} deals with the actual implementation.

\subsection{L0 and L1 Authentication libraries}

When the user starts the application the first steps to perform are to open the communication with the device using Level0 functions from both host and device, and to authenticate the user by checking the login pin, using Level1 functions (again, from both sides). In the basic design diagram we can see how the SEcubeWallet uses the authentication functions and they in turn communicate with the SEcube chip.

\subsection{SecureSqlite3}
As explained before, Wallets are stored as Sqlite DataBases. Fortunately, the SEcube SDK already provides a Level2 API for creating and managing encrypted Sqlite DBs, called SecureSqlite3. This API exploits the SEfile API to wrap some of the functions of the original Sqlite3 library, avoiding OS calls.

SecureSqlite allows to create/edit/save/open databases that when written to the disk are encrypted and can only be read when the SEcube is connected. Additionally, as it is implemented using wrappers, the developer only needs to include the source files in the project and can manage SecureSqlite DB with the same functions used for regular Sqlite DB.

We can see in the diagram the SEcubeWallet application using SecureSqlite to read/write the encrypted wallet stored in disk.

\subsection{Sqlite3}
Because the use of SecureSqlite involves a call to the SEcube, a regular Sqlite3 DB is also used, but this DB is never saved to the disk. Sqlite3 allows for the creation of an In-Memory DB, i.e. a DB whose content is always in the application's memory space and is therefore secured by the operating system. 

The In-memory DB is used for editing. When the user want to save the wallet, i.e. write it to the disk, the contents of the In-Memory DB are dumped to the encrypted SecureSqlite DB. When the user opens a wallet from the disk, the reverse process occurs.

With the In-memory DB, unnecessary calls to the SEcube are avoided while maintaining the contents secured.

\subsection{PassWord Generator}
As the purpose of the application is to securely store passwords, said passwords should be as strong as possible. It does not make sense to protect a password that can be easily cracked by a hacker using brute force. That is why the application also includes a Password Generator.

PwGen is an open source library that generates passwords, that can either be easy to remember, or completely random. Random passwords are more secure, but as the are difficult to remember, their use only makes sense when the user stores them in a wallet manager. Among other aspects, length and characters used (Numbers, Upper cases) can be configured too.

When the user is adding a new entry to a wallet, they can chose to enter a password or to automatically generate one.

\subsection{PassPhrase Generator}
In addition to the Password Generator PwGen, the user has the possibility to generate PassPhrases instead. PassPhrases are a popular alternative because they are easier to memorize and therefore can be longer, which in turns make them more secure. Further details about the usefulness of PassPhrases and how they compare against regular Passwords is given in section \ref{sec:zxcvbn}.

Although the PassPhrase Generator is not a library per se, it was included in the diagram because of its close relation with the PwGen and zxcvbn libraries. It was developed by the author, and it works by selecting random words out of dictionary files. The main options of the generator are which dictionaries to use, how many words to select and the minimum length of each word. 

\subsection{Strength Estimator}
To give the users feedback on how good the password they are about to store is, the application uses the open source project zxcvbn to give an estimation of the passwords entropy, and how long it would take for a hacker to break it. zxcvbn bases its calculation in a number of factors, among them if the password is a common word, or a combination of them, a last name, a date, or letters close to each other in a keyboard (thus the name zxcvbn). With the estimator users are encouraged to create good passwords that are not necessarily completely random and difficult to remember, or annoying to type.

%\vspace{15pt} 
\vskip 25pt

To recap, these are the key aspects of the used libraries:

\begin{itemize}
\setlength\itemsep{0pt}
\item To start the connection with the SEcube, the Level0 library is used
\item To authenticate the user, by checking if the entered login pin is the same as the pin stored in the SEcube, the Level1 library is used.
\item An in-memory database is used for editing the wallet.
\item An encrypted in-disk data base is used for storing the wallet in disk.
\item The application includes a password generator with several options.
\item The application also includes a password strength estimator, so the user has an idea of how good their passwords are.

\end{itemize}

\section{Frameworks, Libraries and software tools} \label{sec:lib}

As explained in the previous section, the core of the design is the use of the SEcube chip to perform security operations in order to encrypt/decrypt some data stored in the host (PC). The requests to the chip are made from the Qt application developed in this work, which runs in the host. Said application exploits the existing C libraries SEfile and SecureSqlite to ease the communication with the SEcube. Additionally, the application also makes use of a random password generator PwGen and a strength estimator zxcvbn open libraries. 

In the following sections a review of the SEcube platform's hardware and software components is given. Then a brief explanation of the C++/Qt framework and why it was chosen. Finally the additional used libraries are presented.

\subsection{The SEcube framework}

``The SEcube™ (Secure Environment cube) Open Security Platform is an open source security oriented hardware and software platform, designed and constructed with ease of integration and service-orientation in mind. The hardware part of the platform was originally designed by Blu5 Group \cite{Blu5}, whereas the software libraries stem from a strong cooperation among international research institutions.'' \cite{GetStart}.

\vspace{5pt}

The main \textbf{hardware} products, explained in detail in the following sections, are:
\begin{itemize}
\setlength\itemsep{0pt}
\item The Chip, named SEcube Chip, or simply \textbf{SEcube}
\item The Development Board, named \textbf{SEcube DevKit}
\item The USB Stick, named \textbf{USEcube Stick}.
\end{itemize}

The SEcube chip is the main hardware component, and both the devkit and USB Stick are designed around it.The Development Board provides several communication protocols as well as debugging capabilities. For the final product the board would be of course too inconvenient to carry, and instead the USEcube Stick is preferred.

\subsubsection{The SEcube Chip}

``The SEcube™ (Secure Environment cube) is a powerful chip which
integrates three key security elements in a single package. A fast
floating-point Cortex-M4 \textbf{CPU}, a high-performance \textbf{FPGA} and an
EAL5+ certified Security Controller (\textbf{Smart Card}).
The result of this innovative combination gives an extremely
versatile secure environment in a single SoC, in which developers
can rapidly implement complex applications and appliances.
... The SEcube™ is the ultimate solution for high-end design,
delivering integration of a flexible, configurable and certified
secure element.'' \cite{SEcubeDS}

We can then see the SEcube chip as a powerful device offering the flexibility of an \textsc{ARM} CPU, the speed of an FPGA and the reliable security of a certified Smart Card, all bounded together and easily integrated in any project thanks to the available communication protocols, among them USB, UART, Ethernet and JTAG. 

The chip includes a true random number generator which relies in 240 noise seeds, all physical and therefore unpredictable. This allows the creation of true random noise. Additionally the user can choose what type of noise they want to generate, for instance white or Fourier noise.

%TODO
\todo{talk more about cpu, low power modes...}

In figure \ref{fig:SEcubeBD} a simplified SEcube architecture is shown.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{chapters/figures/development/SEcubeBlocks.png}
	\caption{SEcube Block Diagram}
	\label{fig:SEcubeBD}
\end{figure}


\subsubsection{Development board: The SEcube DevKit}

The development board integrates the SEcube chip with several peripherals that allow the user to easily communicate, program and debug. (Figure \ref{fig:devboard})

\begin{figure}[ht]
  \centering
  \subfloat[]{\includegraphics[width=0.485\textwidth]{chapters/figures/development/devboard.jpg}}
  \subfloat[]{\includegraphics[width=0.515\textwidth]{chapters/figures/development/devboard_sch.png}}
  \caption{SEcube Devkit}
 \label{fig:devboard}
\end{figure}

The main peripherals in the SEcube devkit are:

\begin{itemize}
\setlength\itemsep{0pt}
\item \textbf{J1000: }\tabto{2.3cm} USB 2.0 to UART 
\item \textbf{J2000: }\tabto{2.3cm} Ethernet 10/100 socket 
\item \textbf{J4000: }\tabto{2.3cm} SEcube embedded FPGA and CPU GPIOs
\item \textbf{J4001: }\tabto{2.3cm} SEcube embedded CPU JTAG
\item \textbf{J4002: }\tabto{2.3cm} microSD card 
\item \textbf{J4004: }\tabto{2.3cm} SEcube embedded FPGA and CPU GPIOs
\item \textbf{J5000: }\tabto{2.3cm} USB 2.0 High Speed 
\item \textbf{LEDx:  }\tabto{2.3cm} Leds 
\item \textbf{SWx00y:}\tabto{2.3cm} Switches 
\end{itemize}

\subsubsection{Final product: USEcube Stick}

For the final product, its is desired that the user carries all the SEcube functionalities in a small and convenient package, so they can encrypt/decrypt the passwords in any PC by just connecting the USEcube Stick and running the SEcubeWallet application.

The USEcube Stick is compatible with any Operating System and the SEcube functionalities are easily exposed to applications and services without installing any driver.

The USEcube offers only the strictly required components: The SEcube chip, a USB 2.0 High-Speed interface and an SDcard socket. See Figure \ref{fig:USEcube} for more details.


Since the USEcube Stick storage capability is based on a external microSD card, the security of the system is improved, as this allows to have a separation of encrypted data from the encryptor/decryptor. Additionally, both the size and the speed can be tuned per the user requirement and can be changed at any time, just replacing the microSD, without buying a new USEcube Stick.
The microSD card socket is embedded in the USB connector allowing to save space making the USEcube Stick very compact and, at the same time dust
and water-resistant.
Since the USEcube Stick is not provided with the JTAG interface, to inject the firmware previously developed and tested on the SEcube DevKit, all the devices come with an embedded secure boot loader.


\begin{figure}[ht]
  \centering
  \subfloat[]{\includegraphics[width=0.485\textwidth]{chapters/figures/development/usb.png}}
  \subfloat[]{\includegraphics[width=0.515\textwidth]{chapters/figures/development/usb_sch.png}}
  \caption{USEcube Stick}
 \label{fig:USEcube}
\end{figure}


\subsubsection{L2 Security APIs}

``The software libraries and design environment allow developers who are not willing or able to produce the security APIs and protocols themselves to exploit the ready functions provided (currently as APIs and soon as services) within the SEcube platform and experience the platform as a high-security black box.'' \cite{L2UserMan}





``From the user/developer point of view, the APIs have been implemented targeting two
nested environments depending on where physically the code runs:
\begin{itemize}
\item \textbf{Device-Side}, including the libraries of basic functionalities that are executed on the embedded processor of the SEcube™-based hardware device.
\item \textbf{Host-Side}, containing libraries of functions executed on the host PC and interface functions for calling services and processes residing on the embedded processor of the SEcube™ device.
\end{itemize} 

From the architectural point of view, the Host-Side Libraries have been implemented targeting 4 hierarchical abstraction levels, and namely:
\begin{itemize}
\item \textbf{Level 0:} Communication Protocol and Provisioning APIs
\item \textbf{Level 1:} Basic Security APIs (Level1 Host-Side – L1)
\item \textbf{Level 2:} Intermediate Security APIs (Level2 – L2)
\item \textbf{Level 3:} Advanced Security APIs (Level3 – L3).
\end{itemize}

At each level, each component represents a "service" for the upper level and relies on "services" provided by the next lower level, only.'' \cite{L2UserMan}

``Level L2 relies on L1 services to provide the APIs for implementing more abstract secure functionalities. Typical examples include APIs for the protection of data both at rest and in-motion, or negotiating parameters (e.g., keys, algorithms) for establishing secure sessions, without being forced to understand in details all the low-level hardware and security mechanisms.''\cite{L2UserMan}

L2 can be considered as the merge of two projects: \textbf{SEfile}, concerning data at rest, and \textbf{SElink}, concerning instead data at motion.

For our project we rely heavily on the development tools provided by the SEfile project, for the secure storage, usage and retrieve of data that requires a high degree of confidentiality, in our case, digital passwords.

\subsubsection{SEfile}

``SEfile targets any user that, by moving inside a secure environment, wants to perform basic operation on regular files. It must be pointed out that all encryption functionalities are demanded to the secure device in their entirety. In addition, SEfile does not expose to the host device details about what, or where it is reading/writing data: thus, the host OS, which might be untrusted, is totally unaware of what it is writing''. \cite{L2UserMan}.

\subsubsection{SecureSqlite}

\subsection{Sqlite3}

\subsection{Graphical User Interface: the Qt framework}
The application's graphical user interface was developed using the \textbf{Qt framework}, version 5.8.0. 

``Qt is a cross-platform application development framework for desktop, embedded and mobile. Supported Platforms include Linux, OS X, Windows, VxWorks, QNX, Android, iOS, BlackBerry, Sailfish OS and others. Qt is not a programming language on its own. It is a framework written in C++. A preprocessor, the MOC (Meta-Object Compiler), is used to extend the C++ language with features like signals and slots. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC''.\cite{Qt}  


For writing, compiling and debugging source code, the IDE \textbf{Qt Creator}, version 4.2.1 was used.

``Qt Creator provides a cross-platform, complete integrated development environment (IDE) for application developers to create applications for multiple desktop, embedded, and mobile device platforms, such as Android and iOS. It is available for Linux, macOS and Windows operating systems''.\cite{QtC}.

\vspace{5pt}
The reasons behind the use of Qt are as follows:

\begin{itemize}
\item Qt is a C++ library, and as such, allows for a seamless use of the C libraries SEfile and SecureSqlite, which are the backbone of this project.

\item Qt is cross-platform, meaning the developed application can be compiled to work on any of the major OSes. In particular, the development was carried out an tested on a Linux machine, but the application should work with no problems in Windows and MacOS. 

\item Because of good designed and ready-to-use display items such as tables, menus and dialogues, it is possible to focus in writing the functional portions of the application without worrying too much about the GUI. And as it is open source, any Qt item can be modified and extended when it does not meet the expectations out of the box. In this project several display elements were improved, as will be seen in section \ref{Implementation}.

\item Thanks to the multitude of functions dedicated to ease the use of C++ libraries and OS calls, one can be more productive, and the resulting code is more reliable. For instance, this project makes extensive use of such libraries, like QSqlDatabase, QString, QProcess, etc. Again, more details are given in section \ref{sec:imp}

\item Related works by research group \textsc{testgroup} from Politecnico di Torino using the SEcube framework, are written in Qt. Namely SecureSqliteBrowser and SEfile\_TXT, were used as base in the initial stages of development. This two projects can be found in the SEfileSDK available online \cite{SEcubeRes}.
%TODO
\todo{research group name  TESTGROUP?}

\item Qt is widely used, meaning it is possible to find tons of documentation, forums and additional libraries on the web. This also ensures the Qt framework will have continuous support from the developers and the community.

\end{itemize}



\subsection{PwGen: Pronounceable Password generator}

The most secure type of passwords are random ones. A random password sufficiently long is considered to be virtually unbreakable. But this rises two problems: First of all, humans are inherently bad at creating true random passwords. Second, a random password is not suited to be remembered or even used (as it probably is too annoying to type). These two reasons motivated the inclusion of a Password Generator.

pwgen is an open source program that generates human friendly passwords that are also secure. It is available in the official Linux repositories, and there is a Windows version as well, but in this work the source files where used.

``The pwgen program generates passwords which are designed to be easily memorized by humans, while being as secure as possible. Human-memorable passwords are never going to be as secure as completely completely random passwords. In particular, passwords generated by pwgen without the -s option should not be used in places where the password could be attacked via an off-line brute-force attack. On the other hand, completely randomly generated passwords have a tendency to be written down, and are subject to being compromised in that fashion'' \cite{pwgen}.

pwgen offers several options that can drastically change the type of generated password. Here is a list of the options available for users of SEcubeWallet:

\begin{itemize}
\setlength\itemsep{0pt}

\item \textbf{Length:} The desired length of the password. It is recommended to be at least 12 for non-random passwords and 8 for random ones.

\item \textbf{-0, no numerals:} 
Don't include numbers in the generated passwords. 

\item \textbf{-A, no capitalize:} 
Don't bother to include any capital letters in the generated passwords. 
    
\item \textbf{-B, ambiguous:}
Don't use characters that could be confused by the user when printed, such as 'l' and '1', or '0' or 'O'. This reduces the number of possible passwords significantly, and as such reduces the quality of the passwords. It may be useful for users who have bad vision, but in general use of this option is not recommended. 
    
\item \textbf{-c, capitalize:}
Include at least one capital letter in the password.

\item \textbf{-n, numerals:}
Include at least one number in the password.

\item \textbf{-s, secure:}
Generate completely random, hard-to-memorize passwords. These should only be used for machine passwords, since otherwise it's almost guaranteed that users will simply write the password on a piece of paper taped to the monitor.

\item \textbf{-v, no vowels:}
Generate random passwords that do not contain vowels or numbers that might be mistaken for vowels. It provides less secure passwords to allow system administrators to not have to worry with random passwords accidentally contain offensive substrings. 

\item \textbf{-y, symbols:}
Include at least one special character in the password.
\end{itemize}

By default pwgen behaves as if the options \textbf{-nc} were used, that is, pronounceable passwords with at least 1 capital letter and 1 number.

The strongest passwords this program can generate are obtained with the options \textbf{-ys}, as it results in random passwords with special symbols. They are very hard to remember, and as said previously, should only be used if the user is willing to open the SEcubeWallet application each time they need to use a password.


\subsection{zxcvbn: Password strength estimation} \label{sec:zxcvbn}

An important feature to have in a password manager is the possibility to realistically estimate how strong a password is, i.e., how hard could it be for hackers to crack it, as there is no point in using the SEcube system to protect weak passwords, that could be easily guessed with brute force attacks. As it is out of the author expertise to write a reliable function to make this estimation, it was decided to use a trusted project developed during the dropbox hackweek event in 2012. The estimator called \textbf{zxcvbn} was originally written in JavaScript aiming for an easy integration with multiple web browsers and OS. Fortunately, the community ported the library to a wide variety of languages including Python, Ruby and C/C++. In this work the later was used. The project is Open Source and available for free use on GitHub \cite{zxgit}.

zxcvbn is regarded by the community as one of the most reliable and mathematically advance open source password estimators. In security forums and discussion it always pops out as an excellent tool, much better than other passwords estimators commonly used in web pages. In \cite{naked}, the author compares zxcvbn to other popular java meters and arrives to the conclusion that only zxcvbn is reliable enough to actually give an useful feedback.
In \cite{gen_est_eval}, the author makes an evaluation of several password generators and strength estimators. PwGen and zxcvbn, the two libraries used in this work, always give excellent results.

``For over 30 years, password requirements and feedback have largely remained a product of LUDS: counts of Lower- and Uppercase letters, Digits and Symbols. LUDS remains ubiquitous despite being a conclusively burdensome and ineffective security practice. zxcvbn is an alternative password strength estimator that is small, fast, and crucially no harder than LUDS to adopt. Using leaked passwords, we compare its estimations to the best of four modern guessing attacks and show it to be accurate and conservative at low magnitudes, suitable for mitigating online attacks. We find 1.5 MB of compressed storage is sufficient to accurately estimate the best-known guessing attacks up to 105 guesses, or 104 and 103 guesses, respectively, given 245 kB and 29 kB. zxcvbn can be adopted with 4 lines of code and downloaded in seconds. It runs in milliseconds and works as-is on web, iOS and Android''. \cite{zxpaper}

``People of course choose patterns — dictionary words, spatial patterns like \texttt{qwerty}, \texttt{asdf} or \texttt{zxcvbn}, repeats like \texttt{aaaaaaa}, sequences like \texttt{abcdef} or \texttt{654321}, or some combination of the above. For passwords with uppercase letters, odds are it’s the first letter that’s uppercase. Numbers and symbols are often predictable as well: \texttt{l33t} speak (3 for e, 0 for o, @ or 4 for a), years, dates, zip codes, and so on.
As a result, simplistic strength estimation gives bad advice. Without checking for common patterns, the practice of encouraging numbers and symbols means encouraging passwords that might only be slightly harder for a computer to crack, and yet frustratingly harder for a human to remember. xkcd nailed it''. (see figure \ref{fig:xkcd}). \cite{zxdropbox}

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=\columnwidth]{chapters/figures/development/xkcd.png}
  \caption{Password strength, xkcd \cite{xkcd}}
  \label{fig:xkcd}
\end{figure}

To put it in other words, the authors of the project argue that a password like \texttt{\textbf{correcthorsebatterystaple}} (a nonsense English phrase) is more strong than a password like \texttt{\textbf{Tr0ub4dour\&3}}, even if the former does not have any upper cases or numbers, and the latter seems more complicated.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=\columnwidth]{chapters/figures/development/zxcvbn_comp.png}
  \caption{comparison between zxcvbn and popular websites' strength meters}
  \label{fig:tablez}
\end{figure}

The table in figure \ref{fig:tablez} (taken from \cite{zxdropbox}), show how zxcvbn is different from strength meters used in popular web services. (disclaimer: The data in the table is from 2012). From it we can learn:

\begin{enumerate}
\setlength\itemsep{0pt}
\item Passwords like \texttt{\textbf{qwER43@!}}, which is a spatial password: it uses the keys \texttt{qwer4321}, with shift pressed for the keys \texttt{er} and \texttt{21} (the \texttt{@} symbol in the English keyboard is \texttt{shift+2}), is not considered week by most of the meters, but it should. It is probably due to the fact that it includes a combination of numbers and symbols that makes it look strong, but in reality, because of keyboard spatiality, is not.

\item Passwords like \texttt{\textbf{Tr0ub4dour\&3}}, which is generated by replacing some of Troubadour letters with numbers, and adding two more characters, is regarded as a very strong password for all of the meters except zxcvbn. Even if the base word is uncommon, and it has some variations, it is not long enough to be considered so strong.
\item A password like \texttt{\textbf{correcthorsebatterystaple}} is not considered strong by most of the meters except zxcvbn, and it is not even allowed in some cases because it lacks numbers, Upper-cases or symbols.
\end{enumerate}

The superiority of zxcvbn over the other meters in the table may seem like cherry picking, but the way zxcvbn is constructed explains these differences.

\subsubsection*{Matching}

Enumerates all the (possibly overlapping) patterns it can detect. Currently zxcvbn matches against:

\begin{itemize}
\setlength\itemsep{0pt}

\item \textbf{Dictionaries:} Common words the user is likely to use as password. Multiple dictionaries, in a simple .txt format can be used. In this work, we present a few: English words, Italian words, names and surnames, Burnett’s 10,000 common passwords, words from tv and films. The match has an associated frequency rank, where words like the and good have low rank, and words like photojournalist and maelstrom have high rank. This lets zxcvbn scale the calculation to an appropriate dictionary size on the fly, because if a password contains only common words, a cracker can succeed with a smaller dictionary. For all dictionaries, match recognizes uppercasing and common \texttt{l33t} substitutions.

\item \textbf{Spatial keyboard patterns:} Some users are likely to choose passwords based on spatial pattern. For instance a user could choose the first row of letters from right to left: \texttt{poiuytrewq} as they password. \textsc{qwerty} keyboard, Dvorak keyboard, and keypad are considered.

\item \textbf{Repeats}: Users are also prone to use repetition of characters, like \texttt{rrrr}. 

\item \textbf{sequences}: Numeric or alphabetic sequences like \texttt{123} or \texttt{fedcba}

\item \textbf{years and dates}: The year or full date of a special event, like anniversary or birthday. Years from 1900 to 2019 are considered and dates in different formats. (3-13-1997, 13.3.1997, 1331997). 

\end{itemize}

\subsubsection*{Entropy calculation of a single pattern}
Depending on the type of matching, the entropy calculation is done differently, but for all the cases the idea is the same: How many different cases a hacker would have to try before guessing the pattern? For example, for the repeat case, if the user chooses \texttt{zzzzz}, as it is repeated five times, and if we assume the hacker starts by the letter a, then the number of cases would be $ N = 26 \times 5 = 130 $. (The sequence the hacker would try is: \texttt{a, b, c, d...,z, aa, bb, cc,...,...,zzzz, aaaaa, bbbbb,....zzzzz}).


As the number of possible cases can be pretty large, the entropy is not given as a raw value but as $e = log_{2}(N)$, known as the entropy bits, and in some cases as $f = log_{10}(N)$, known as the log entropy. In the example, entropy bits: $e = log_{2}(130) = 7 bits$.

The entropy bits and log entropy are related by:
\[N = 2^{e} = 10^{f}\]
\[f = e \times log_{10}(2)\]
\[e = f \times log_{2}(10)\]


\subsubsection*{Minimum entropy search of whole password}

Given the full set of possibly overlapping matches, the algorithm finds the simplest (lowest entropy) non-overlapping sequence. For example, if the password is damnation, that could be analysed as two words, dam and nation, or as one. It’s important that it be analysed as one, because an attacker trying dictionary words will crack it as one word long before two.

zxcvbn calculates a password’s entropy to be the sum of its constituent patterns. Any gaps between matched patterns are treated as brute-force "patterns" that also contribute to the total entropy. That a password’s entropy is the sum of its parts is a big assumption. However, it’s a conservative assumption. By disregarding the "configuration entropy" — the entropy from the number and arrangement of the pieces — zxcvbn is purposely underestimating, by giving a password’s structure away for free: It assumes attackers already know the structure (for example, surname-bruteforce-keypad), and from there, it calculates how many guesses they’d need to iterate through.\cite{zxdropbox}

\subsubsection*{From entropy bits to rank and estimated crack time} \label{sec:zxLevels}

To estimate the cracking time, it is necessary to make some assumptions about what kind of attack will be subjected the user. zxcvbn considers four possible scenarios according to the number of attempts/time the hacker can do:

\begin{enumerate}
\setlength\itemsep{0pt}

\item \textbf{Online throttling (100 per hour):} Online attack on a service that ratelimits password authentication  attempts.
  
\item \textbf{Online no throttling (10 per second): }Online attack on a service that does not ratelimit or where an attacker has outsmarted ratelimiting.

\item \textbf{Offline slow hashing (1e4 per second): }Offline attack. assumes multiple attackers, proper user-unique salting, and a slow hash function with moderate work factor, such as bcrypt, scrypt, PBKDF2.

\item \textbf{Offline fast hashing (1e10 per second): }Offline attack with user unique salting but a fast hash function like SHA1, SHA256 or MD5. A wide range of reasonable numbers anywhere from one billion to one trillion guesses per second, depending on number of cores and machines. Ballparking at 10B per sec.

\end{enumerate}

%  0 # . (guesses < 10^3)
%
%  1 # very guessable: protection from throttled online attacks. (guesses < 10^6)
%
%  2 # somewhat guessable: protection from unthrottled online attacks. (guesses < 10^8)
%
%  3 # safely unguessable: moderate protection from offline slow-hash scenario. (guesses < 10^10)
%
%  4 # very unguessable: strong protection from offline slow-hash scenario. (guesses >= 10^10)

zxcvbn then ranks a password with a security level from 0 to 4 according to its entropy value:
\begin{itemize}
\setlength\itemsep{0pt}
\item \textbf{Level0 if ($N<10^{3}$):} Too guessable, risky password
\item \textbf{Level1 if ($N<10^{6}$):} Very guessable, protection from throttled online attacks.
\item \textbf{Level2 if ($N<10^{8}$):} Somewhat guessable, protection from unthrottled online attacks.
\item \textbf{Level3 if ($N<10^{10}$):} Safely unguessable, moderate protection from offline slow-hash scenario.
\item \textbf{Level4 if ($N>10^{10}$):} Very unguessable: strong protection from offline slow-hash scenario

\end{itemize}
Where N is the number of possibilities a hacker would have to try for crack the password. So for instance, if the password is level 2, it could be cracked in around $10^{8}$ guesses.

For Level0 the above rule in terms of the entropy bits is $e<log_{2}(10^{3})$.
In terms of the log entropy bits, it simply is $f<3$.

The level and estimated crack time for each type of attack is presented to the user. With this information, the user will, hopefully, choose a Level4 password. Additionally, the user also receives  feedback about how the password was cracked, so they know how to improve it.

\subsection{PassPhrase Generator}

From the previous two sections there seems to be a disagreement on what a good password looks like. PwGen can generate totally random passwords or pseudo-random pronounceable passwords, but even the later go against what zxcvbn proposes: PassPhrases that are very easy to remember, but long enough to give excellent entropy results. To fill this gap, a PassPhrase generator that gives results along the lines of \texttt{CorrectHorseBatteryStaple} is used.

The PassPhrase generator developed by the author works by randomly picking out words from dictionary files. The user can tune the PassPhrase generation as follows:

\begin{itemize}
\setlength\itemsep{0pt}
\item \textbf{Dictionaries: }The user must select appropriate dictionaries, containing a sufficiently large number of lines (larger than 10000) to ensure the picked words are really random. The English and Italian dictionaries used by zxcvbn are a good example. The user can work with as many dictionaries as desired, an the format must be one word per line. Only the first word of each line is counted, as everything after a space is trimmed.

\item \textbf{Number of words: }The user can configure the number of words the generated PassPhrases are composed of. The recommended size is four, but it can be as long as the user wants.

\item \textbf{Minimum Length of Words: }With this option is possible to select only random words whose length is higher than a certain value. This is to make sure the resulting PassPhrase is too short and therefore too insecure. The drawback here is that the higher the selected threshold, the fewer the available words in the dictionaries.

\item \textbf{Only use infrequent words: }If the dictionaries follow the same format as those used for zxcvbn, that is, the words are ordered by frequency, having the most uncommon words in the lower part of the dictionary, the user can then ask to generate PassPhrases containing only unusual words. The drawback here is, again, fewer words to choose from. The percentage of words that are used is configurable.

\item \textbf{Capitalize first letter: }To make the PassPhrases more readable, the first letter of each word can be capitalized.
\end{itemize}



\subsection{Device side development: Eclipse}

\section{Implementation} \label{sec:imp}

%TODO
\todo{subdirs structue in qt project}

In the following sections each of the elements and functionalities of the application will be explained, how they were implemented, some interesting pieces of code and examples of use.

\subsection{User authentication}

When the user starts the application, the first window to appear is the Login Dialogue, shown in figure \ref{fig:logina}. In it the user is asked to enter the login pin and by clicking accept the Challenge-Based Authentication process between the SEcubeWallet application and the SEcube chip starts. If the authentication fails because the entered pin is wrong, the message in \ref{fig:loginb} is shown. If it fails because there was already an opened session, the confirmation dialogue shown in \ref{fig:loginc} appears. If the authentication is completed successfully the user is granted access to the main window.

\begin{figure}[ht]
  \centering
  \subfloat[Login Dialogue\label{fig:logina}]
  {\includegraphics[width=0.3\linewidth]{chapters/figures/development/login.png}}
  {}
  \subfloat[Wrong Password\label{fig:loginb}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginWrong.png}}
  {}
  \subfloat[Already an open session\label{fig:loginc}]
  {\includegraphics[width=0.3\textwidth]{chapters/figures/development/loginOpen.png}}
  \caption{Login Dialogue and possible outcomes}
 \label{fig:login}
\end{figure}

The authentication process begins with the discovery of SEcube devices connected to the PC. This is achieved using Level0 APIs as seen in the listing \ref{lis:dis}. Each discovered device is added to the \texttt{QComboBox} displayed in the login dialogue and to a \texttt{QList}.

\begin{lstlisting}[style=customc, float=htb, caption={Connected Devices discovery}, label = {lis:dis}]
//// *** variables declaration ***
se3_disco_it it;
QList<se3_disco_it> device_found;
QComboBox* chooseDevice;
bool found = true;

//*** Refresh button slot *****
L0_discover_init(&it); //initialize iterator
while((found = L0_discover_next(&it))){ //move to next device
  chooseDevice->addItem(QString::fromLocal8Bit(
    it.device_info.path, -1)); //add to GUI
  device_found.push_back(it); //add to QList
}
\end{lstlisting}

The user then selects one of the discovered devices using the \texttt{QComboBox}, enters their login pin and clicks accept. This triggers the listing \ref{lis:login}. The first step is to open the device communication using the Level0 function \texttt{L0\_open}. Then \texttt{L1\_login} starts the actual challenged based authentication using the login pin entered by the user. Using this type of authentication ensures the login pin is never communicated between the devices and stolen with a physical attack on the USB cable. Rather, a random number is generated in the host and transmitted to the device. The login pin is then used in both the host and the device to encrypt this random number using a \texttt{pbkdf2} function. The resulting key on the device is sent to the host, who compares it with its own key. If they are the same it means the login pin entered by the user is equal to the login pin stored in the device, and the only information transmitted are random numbers that an attacker cannot understand. (The actual authentication procedure implemented is a little bit more complex, but is based on the same idea described here).
%TODO
\todo{explain better the challenge based}

\begin{lstlisting}[style=customc, float=htb, caption={Open device and try to login}, label = {lis:login}]
// *** variables declaration ***
//use selected index at QComboBox to retrieve 'it' from QList.
int device_index = chooseDevice->currentIndex();
se3_disco_it it = device_found.at(device_index);

se3_session s; 
se3_device dev;
int ret;
bool logout = false; //if true, L1_login logs out first

//*** Accept button slot *****
if(!dev.opened) // open communication with device
  if((L0_open(&dev, &(it.device_info), SE3_TIMEOUT))!= SE3_OK)
    exit(1); //error

ret = L1_login(&s, &dev, pin, SE3_ACCESS_USER, logout); //login

if (ret != SE3_OK){    //error at login
  if (ret == SE3_ERR_PIN) //The password is wrong
    show_wrong_pass_messsage;
    
  else if (ret == SE3_ERR_OPENED){
    // there is already an opened session, ask user if he wants to close it
    if(confirmation_dialog_reply == Yes){ 
      logout = true; 
      call_this_function_again;
      //next time L1_login will close the existing session
    }
  }else            
    exit(1);//other error
}else
  accept();//All ok, go to main window
\end{lstlisting}

After both device and host have the same key, it is used to encrypt the communication channel. A token is generated in the device and transmitted on the encrypted channel to the host. This token is a random number, and is used from that point on to validate any communication between host and device. The SEcubeChip does not accept any command from the host if the token it sends is not the correct one. The only command accepted without a token is off course, login. In the logout procedure, this token is cleared (set to zeros), so a login later on is possible.

One problem found during the development of the application is the followin: If after login in, the SEcubeWallet application crashes, the logout command, that is usually issued when closing, is never executed, and the device remains with an active token value. Therefore, when the user launches the application again, the login will fail, because the device expects a token value from the host. To solve this issue a few options were considered:

\begin{itemize}
\setlength\itemsep{0pt}
\item Make sure the application never crashes. Because software applications are rarely completely bug-free, and even if they are, an external problem like a bug in the OS can make them crash, this option is not feasible. 
\item Make sure the logout command is issued even in the case the application crashes. This option sounded promising, and a two-process idea was even developed. Process 1 is only in charge of calling Process 2, in which the actual application was executed. if Process 2 crashes, Process 1 remains alive and performs the logout procedure. To make this work, shared memory was used to communicate the session variable (were the token is stored), so both processes could send commands to the device. The idea was latter on dropped because of two main reasons: First of all, it did not solve the case were the problem is external (OS bug), secondly, it was too complicated because of the sharing memory mechanism (The session variable is a fairly complex structure, with a lot of pointers), and because the token was being shared by two processes, this could open another possibility of attacks.
\item As the two previous ideas failed, it was decided that a small modification to the login behaviour on the SEcube firmware was necessary. The modification consist on letting the login function clear the token field if necessary. This does not compromise the security of the system because access to the chip is only granted if the login pin entered by the user is the right one. One concern that may rise is that, while an application is using the SEcube, another one could close the session by issuing a Login command, but this is not possible because the \texttt{L0\_open} function only allows one process to communicate with the chip at a time, using a file locker in the .se3magic
file saved in the SEcube SDcard.
\end{itemize} 

The new behaviour is implemented in listings \ref{lis:se3cmd1}.
If after a crash the session in the SEcube remains open, and the host tries to login again, the SEcube returns the new error code \texttt{SE3\_ERR\_OPENED}. The host then can decide if it wants to force the SEcube to close the opened session so it can login, with the new command \texttt{SE3\_CMD1\_LOGOUT\_FORCED}, which forces a logout without checking the token. After this command the host can login as usual. This steps are included in the host side \texttt{L1\_login} function, which now has an additional parameter to control whether to force a logout or not. This parameter is the one used in listings \ref{lis:login}, set to true when the user clicks \textsc{yes} in the confirmation dialogue asking whether or not to close the previous session.

\begin{lstlisting}[style=customc, float=htb, caption={Modification in SEcubeFirmware, file se3\_cmd1.c}, label = {lis:se3cmd1}]
if (se3c1.login.y) { // if there is already an opened session
  if (memcmp(se3c1.login.token, req_params.token, SE3_L1_TOKEN_SIZE)) { //and token mismatch
    if (req_params.cmd==SE3_CMD1_CHALLENGE)//someone (maybe same user after a crash) trying to login.
      return SE3_ERR_OPENED;//notify host there is already an opened session, if host wants to continue, it will call SE3_CMD1_LOGOUT_FORCED
    else if (req_params.cmd==SE3_CMD1_LOGOUT_FORCED)//if the user agreed to close the existing session by forcing a logout
      req_params.cmd=SE3_CMD1_LOGOUT;//call logout as usual  
    else
      return SE3_ERR_ACCESS;
  }
}
\end{lstlisting}




\subsection{Main Window}

The SEcubeWallet GUI's main window developed using Qt is shown in figure \ref{fig:mainWindow}.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=1.2\columnwidth]{chapters/figures/development/mainWindow.png}}
  \caption{SEcubeWallet main window}
  \label{fig:mainWindow}
\end{figure}

The main window is composed of the following elements:

\begin{itemize}
\setlength\itemsep{0pt}
\item \textbf{Table View:} Used for displaying the wallet entries. It resizes smoothly with the window, can be ordered by any of the columns, and the passwords are hidden by default but can be shown if the user wants to.
\item \textbf{Filters:} The user can search in each of the table's columns using filters. These filters are implemented inside a separate container, but they resize together with the table.
\item \textbf{Entries Tool Bar:} It is positioned to the left of the table. It has the actions: add/edit/delete entries, show passwords, fit table, change date filter, launch domain and select table.
\item \textbf{Tables Tool Bar:} It is positioned to the top right of the table. It has the actions: add/rename/delete table.
\item \textbf{Wallets Tool Bar:} It is positioned to the top left of the table. It has the actions: new/open/delete/save/save as/close Wallet. 
All of the above Tool Bars are movable.
\item \textbf{Menu Bar:} It is positioned at the top of the window. It contains all the previous actions, plus preferences and help.
\item \textbf{Status Bar:} Positioned at the bottom of the window, it is used to display some success/error messages to the user and the current wallet name.
\end{itemize}


\subsection{Preferences Subwindow}
\subsection{Help Subwindow}

\subsection{New Wallet action}

When the user triggers the the \texttt{New\_Wallet} action, the first step to execute is to check if there is another wallet opened and if it has unsaved changes. If, so the confirmation dialogue in figure \ref{fig:confSave} is shown, so the user can decide whether to save the changes, discard them, or cancel the creation of a new wallet.
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \centerline{\includegraphics[width=0.6\columnwidth]{chapters/figures/development/confSave.png}}
  \caption{Save Confirmation dialogue}
  \label{fig:confSave}
\end{figure}

In case the user clicks \texttt{Save}, the \texttt{Save\_Wallet} action is triggered before continuing. \texttt{Discard} continues without saving, and \texttt{Cancel} returns without doing anything.

If the process continues, the next step is to close any previous in-memory database handlers, save the \texttt{table\_view} geometry (if any), and open a new in-memory database using the Qt class \texttt{QSqlDatabase}, as seen in listings \ref{lis:newDB}.

\begin{lstlisting}[style=customc, float=htb, caption={New in memory database}, label = {lis:newDB}]
QSqlDatabase dbMem; //The database handler, declared in header 

//Check if sqlite is installed on OS
if(!(QSqlDatabase::isDriverAvailable("QSQLITE")))
  exit (1); //the application does not work without Sqlite

if (dbMem.open()){ 
  save_table_geometry;
  dbMem.close();//close any prev. opened database
}

dbMem = QSqlDatabase::addDatabase("QSQLITE");
dbMem.setDatabaseName(":memory:"); // in-memory database
if(!dbMem.open()){
  return;//Error opening, do nothing
}
\end{lstlisting}

As explained before the in-memory data base is used for editing. It has the advantage of being fast because there is no access to the hard disk, and secure, because all the data is in the application memory space, and therefore is protected by the OS.

The last step is to update the GUI state, by enabling some action like \texttt{Add\_Table} and \texttt{Save\_Wallet}, and disabling others, like \texttt{Delete\_Table} and \texttt{Rename\_Table}.

\subsection{Save Wallet action}
To write the wallet contents to the disk, it is necessary to have a filename, so the first step is to check if the user already entered one (from previous saves). If not, with the dialogues in figure \ref{fig:saveWallet} the user can choose the directory and the filename to save.

\begin{figure}[ht]
  \centering
  \subfloat[User can enter a New name. Current wallets are displayed\label{fig:saveWalleta}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/saveWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Save Wallet dialogues}
 \label{fig:saveWallet}
\end{figure}

The need for two dialogues instead of a regular file browser comes from the fact that the chosen filename will not be readable from the OS, since \texttt{SEfile} also encrypts it. Similarly, wallets already saved in the directory cannot be displayed with a regular file browser, so it is necessary to use the \texttt{SEfile} function \texttt{secure\_ls} and display its output in the list seen in figure \ref{fig:saveWalleta}. The declaration of this function is in listings \ref{lis:securels}. To chose the working directory, it is enough to use the \texttt{QFileDialog} class. If the user wishes they chose an existing filename and can overwrite the correspondent wallet.

\begin{lstlisting}[style=customc, float=htb, caption={\texttt{secure\_ls} declaration}, label = {lis:securels}]
 /* This function identifies which encrypted files and encrypted directories are present in the directory pointed by path and writes them in list. It only recognizes the ones encrypted with the current environmental parameters.*/
 
uint16_t secure_ls(    //returns 0 in case of success
  char *path,          //[in]Path to the directory to browse
  char *list,          //[out]Allocated array to store filenames
  uint32_t *list_length//[out]Num of char written in list
);
\end{lstlisting}


After having a filename the next step is to read all of the tables in the current in-memory database, row by row. For each row a \texttt{sqlite} statement of the form \texttt{INSERT INTO table VALUES(user, dom, pass, date, desc)} is created. All of them are merge into a single statement which is executed into the secured in-disk database. This ensures only one access to the SEcube and disk. This process is somewhat slow and the GUI is disabled while it is performed. A simplified version of the code is shown in listing \ref{lis:save} 

\begin{lstlisting}[style=customc, float=htb, caption={simplified Save process}, label = {lis:save}, escapechar=¬]
sqlite3 *dbSec;    //Secure database declaration, in header
QSqlDatabase dbMem;//The database handler, declared in header 
QSqlQuery query;   //To exec sqlite statements, dec. in header

//Create Sqlite DB, with filename specified by user If SEcube is connected, the resulting file is encry.
sqlite3_open_v2 (fileName.toUtf8(),   
                &dbSec, 
                SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE , 
                NULL) 
                
QString finalSql; //To Merge all the sqlite statements.
static const QString insert = 
  QStringLiteral("INSERT INTO '%1' VALUES(%2);"); //statement
  
dbMem.tables(QSql::Tables); //list of the tables in in-memory DB
tables.prepend("NoEmpty");  //Workaround: prepend Empty table   ¬\label{line:empty}¬
foreach (const QString table, tables) { // loop all the tables
   QString sql = "create table "+table+ //Create table statement 
                "(id integer primary key, "
                "Username TEXT, "
                "Domain TEXT, "
                "Password TEXT, "
                "Date TEXT, "
                "Description TEXT );" ; 
  sqlite3_exec(dbSec, sql.toUtf8(), NULL, 0, &zErrMsg);// exec
  
  if (table=="NoEmpty"){//just an empty table
    set_values_to_empty;
    finalSql += insert.arg(table).arg(values.join(", "));
  }else{
  query.prepare(QString("SELECT * FROM [%1]").arg(table));
  query.exec()
  while (query.next()){ //row by row
    values = query_read_row();
    finalSql += insert.arg(table).arg(values.join(", "));
  }
}
//single write into secure database, fill the tables
sqlite3_exec(dbSec, finalSql.toUtf8(), NULL, 0, &zErrMsg);
\end{lstlisting}

One problem found during the open process of a secured in-disk wallet (that will be explained latter on) is that the first table is always corrupt and gives the error: \texttt{database disk image is malformed}. The error only occurs when using the SEcube version of the sqlite library. Because it was impossible to find the origin of the error, it was decided to use a workaround: In the save wallet process, an empty table is inserted at the beginning of the in disk database (see line \ref{line:empty} in listings \ref{lis:save}). When opening the wallets, the empty table is simply ignored. With this, the real tables are always correctly read an the application works as intended.


\subsection{Save Wallet As action}

This action is very simple, it just clears the current filename (if any), and calls the \texttt{Save\_Wallet} action; as there is no filename, the user is forced to enter a new one. The only point to be careful about is that, in case the \texttt{Save\_Wallet\_As} process is aborted, the previous filename needs to be recovered, so before clearing, the filename is temporary stored in case it is needed.

\subsection{Open Wallet action}
As for the \texttt{New\_Wallet} action, the first step is to check for unsaved changes and show the dialogue in figure \ref{fig:confSave}

If the user decides to continue, the dialogues in figure \ref{fig:openWallet} allow them to choose the wallet to open from the list.

\begin{figure}[ht]
  \centering
  \subfloat[User chooses the wallet to open from the list\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/openWallet.png}}
  {}
  \subfloat[if \texttt{Browse} is clicked a \texttt{QFileDialog} is launched\label{}]{\includegraphics[width=0.48\textwidth]{chapters/figures/development/directories.png}}
  \caption{Open Wallet dialogues}
 \label{fig:openWallet}
\end{figure}


%
%\subsection{Close Wallet action}
%\subsection{Delete Wallet action}
%
%\subsection{Add Table action}
%\subsection{Delete Table action}
%\subsection{Rename Table action}
%
%\subsection{Table View widget}
%\subsection{Filters}
%
%\subsection{Select Table}
%\subsection{Add Entry action}
%\subsection{Edit Entry action}
%\subsection{Delete Entry action}
%\subsection{Show Passwords action}
%\subsection{Fit Table action}
%\subsection{Change Date Filter type action}
%\subsection{Launch Domain action}
%
%\subsubsection{Status Bar}









\subsection{PwGen: Pronounceable Password Generator}
As seen from previous sections, the PwGen program is open source and available in the official Linux repositories. A very simple way of including its functionalities into the SEcubeWallet application would be to use a \texttt{Qprocess} to call PwGen as an external program. Although is tempting to use this solution because of its simplicity, there are three drawbacks with this approach:

\begin{enumerate}
\item It would require for the user to install the PwGen program, as it is usually not included in common Linux distributions.
\item It would not be very portable, because even if there is a PwGen version for windows, the available version or input parameters could differ in different platforms.
\item Security could be compromised. As PwGen needs to communicate the generated password back to the SEcubeWallet application, an attacker could steal the password in this process.
\end{enumerate}

For these reasons, it was decided to embed the PwGen sources directly into the application, this ensure the password never leaves the application memory space. 
To include the sources into the application, some slight modifications (mostly simplifications) to the PWGen \texttt{main()} function were necessary. This is because the original sources are intended for the use of PwGen as a independent console program called by users, so the \texttt{main()} contains code dedicated to parse the input arguments in the standard \texttt{argc argv[]} fashion. Only the \texttt{pwgen.c} and \texttt{pwgen.h} --- files where the \texttt{main()} is implemented --- were modified.

\subsubsection*{Options GUI}
As all the options for PwGen besides the password length are yes or no questions, the checkable list shown in figure \ref{fig:pwgenSett} is perfect for this purpose.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/pwgenSett}
  \caption{PwGen settings in the preference window}
  \label{fig:pwgenSett}
\end{figure}

When the \texttt{OK} button is clicked, all the values are saved using the \texttt{QSettings} class, so they are available even after restarting the application.

\subsubsection*{Usage}

When the \texttt{Generate Password} button in the \texttt{AddEntry} class is clicked, the settings values stored in with the \texttt{QSettings} class are read and from them a \texttt{char[]} with the PwGen options syntax is built. Before calling the Generator, it is necessary to allocate a memory space equal to the desired password length (in \texttt{char}) and pass this buffer as a pointer (\texttt{char*}) to PwGen. PwGen will write the generated password in this space. This steps can be seen in the listing \ref{lis:pwgen}


\begin{lstlisting}[style=customc, float=htb, caption={PwGen call inside AddEntry}, label = {lis:pwgen}]
//read user settings (if existent)
if (settings.value("passGens/pwgen/1cap").toBool())
    options.append("c");
if (settings.value("passGens/pwgen/1num").toBool())
    options.append("n");
if (settings.value("passGens/pwgen/1spec").toBool())
    options.append("y");
if (settings.value("passGens/pwgen/noAmb").toBool())
    options.append("B");
if (settings.value("passGens/pwgen/noCap").toBool())
    options.append("A");
if (settings.value("passGens/pwgen/noNum").toBool())
    options.append("0");
if (settings.value("passGens/pwgen/noVow").toBool())
    options.append("v");
if (settings.value("passGens/pwgen/random").toBool())
    options.append("s");

//check if user entered an integer, if not, default is 16
if(settings.value("passGens/pwgen/len").toInt())
    length = settings.value("passGens/pwgen/len").toInt();

//allocate space for password
buf = (char*)malloc(length+1);
if(!buf){
  return;//error, could not allocate
}
//actual call to password generator
main_pwgen(
  options.length(),               //int, number of options 
  options.toLatin1().constData(), //char *, options 
  length,                         //password length 
  buf                             //char *, to return the password           
);
genPass = QString::fromLatin1(buf,length);
free(buf);
\end{lstlisting}

\subsubsection*{Results}

A few examples of the resulting Passwords are show in table \ref{tab:pwgenExm}, with their respective zxcvbn Log entropy score and Level. As expected, the passwords with highest entropy are those obtained using the \texttt{-s} (Random) and \texttt{-sy} (Random and especial characters) options. Even with only 6 characters it is possible to get a Level 4 password like \texttt{TBw4)9}. The drawback is, they are hard to remember and type. 

On the contrary, a password obtained with the \texttt{-BA0} (No ambiguous, do not capitalize, no numbers, pronounceable) options, like \texttt{nofosootei}, only reaches a Level2, but it is very easy to remember and type.

The large number of options PwGen offers, together with the PassPhrase generator and the l33t converter, give the users a lot of types of passwords, each suited for different situations, given SEcubeWallet great flexibility.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{A few PwGen generated passwords}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{4cm}ccc
@{}}
\toprule
\hd{Password} & \hd{Length} & \hd{Options} & \hd{Log Entropy \\ \& Level}  \\ \midrule

iesohGhai3   & 10 & -   &  9.75 (Level 3)\\
ees0cooLo2   & 10 & -   & 10.47 (Level 4)\\
dX042wKqlW   & 10 & s   & 17.86 (Level 4)\\
@!,Q*l5\}+H  & 10 & ys  & 18.15 (Level 4)\\
TBw4)9       &  6 & ys  & 11.62 (Level 4)\\
B7t34Lck     &  8 & v   & 11.87 (Level 4)\\
nofosootei   & 10 & BA0 &  6.50 (Level 2)\\
\bottomrule  
\end{tabular*}
\label{tab:pwgenExm}
\end{table}

\subsection{zxcvbn Password strength estimator}

The original zxcvbn project, developed in CoffeeScript became so popular it was ported to a large variety of languages. In this work the C/C++ version available at \cite{zxgit} was used. The files used in this project are:

\begin{itemize}
\setlength\itemsep{0pt}
\item \textbf{zxcvbn.c} Main source file
\item \textbf{zxcvbn.h} Main header file
\item \textbf{dict-generate.cpp} Used for generating the dictionary sources
\item \textbf{Makefile} To compile the dictionary generator and main program.
\item \textbf{words-*.txt} A few examples of dictionary files in plain text format.
\end{itemize}

Besides source files, zxcvbn also needs to compile the dictionary files, but first lets define what is a dictionary, why are they important and why they need to be compiled (For general dictionaries only. User dictionaries are small and can be added at runtime).

\subsubsection*{General dictionaries}

Dictionaries are a crucial part of the algorithm, because they are used estimate the security level of a password according to how common the used words (if any) are. A password containing words present in any of the dictionaries will be easier to crack as hackers will probably try out those specific words or a combination of them.

General dictionaries contain a large number of words that are useful for all users. Examples of these type of dictionaries (included in this work) are:
\begin{itemize}
\setlength\itemsep{0pt}
\item 100000 English words from wikipedia.
\item 88800 Last names from the US census database
\item 39000 English words from tv and film from the wikiproject \cite{wiktionary}
\item 47000 Most common passwords from Burnett \cite{burnett}
\item 15480 Italian words from the \textsc{badip} project \cite{badip} 
%TODO
\todo{More dicts, see bookmarks}
\item 4276 Female names from the US census database 
\item 1220 Male names from the US census database
\end{itemize} 

As the dictionary files in plain text are pretty large, the algorithm does not read from them directly. Instead, a \texttt{DicNodes} array is generated, using the tool \texttt{dict-generate}, and this array is compiled into the source code.
To add their own dictionaries, the users need to make sure they are saved as plain-text, (.txt UTF-8), and stored into the zxcvbn directory. The files must have one word per line, with the first word being the most common one. So for instance, in the English dictionary the first word is \texttt{the} and the last one is \texttt{surma}. This is important as it is used to calculate the entropy of the passwords. A password containing the word \texttt{surma} is far more secure that one containing the word \texttt{the}.

\subsubsection*{Static Library vs Shared Library}

Because the dictionaries are transformed into a source file and then compiled together with the main program, it is not possible to add, remove or modify dictionary files after the sources are compiled. Therefore the zxcvbn library can not be embedded into the SEcubeWallet application as a static library (or using the C sources directly), but rather, a \textbf{shared library} approach was followed, which allows the dynamic unload/update/load of the library. This has some performance penalties over static libraries, but it is the only way to give the users the possibility of customize the dictionaries as they please.

\subsubsection*{Compilation process}

The steps performed by the \texttt{makefile} in order to compile the dictionaries and sources are:

\begin{enumerate}
\setlength\itemsep{0pt}
\item Compile the source file \texttt{dict-generate.cpp} to obtain the dict generator executable\texttt{dictgen}.
\item Execute \texttt{dictgen} with the names of dictionaries to process as input argument. As a result the file \texttt{dict-src.h} is created.
\item Compile the files \texttt{zxcvbn.c} and \texttt{zxcvbn.h} together with the just generated \texttt{dict-src.h}, using the gcc flag \texttt{-fPIC} so the resulting object file \texttt{zxcvbn-inline-pic.o} is suitable for library inclusion.
\item Generate the shared library \texttt{libzxcvbn.so} from the object file. This is the library used by the SEcubeWallet sources.
\end{enumerate}

The compilation process can be started by the user from the preference window, where they can also select the dictionaries to use, or clean the generated files. The compiling is made with OS calls, through the use of \texttt{QProcess}. To avoid the application from crashing or getting stuck, the \texttt{Qprocess} has a timeout. As the compile process may take a while depending on the dictionaries size, this timeout can be configured by the user. In figure \ref{fig:zxcvbnGen} the GUI for these actions is shown.

\begin{figure}[ht]
  \centering
  \subfloat[Tab dedicated to zxcvbn preferences]{\includegraphics[width=0.5\textwidth]{chapters/figures/development/zxcvbnGen.png}}
  \subfloat[Checkable dialogue to enable dictionaries, appears after clicking the Choose button]{\includegraphics[width=0.4\textwidth]{chapters/figures/development/dictListSett.png}}
  \caption{zxcvbn general dictionaries configuration}
 \label{fig:zxcvbnGen}
\end{figure}

\subsubsection*{Dynamic Library loading}

To manage the zxcvbn shared library at runtime it is possible to use the qt class \texttt{Qlibrary}, which provides access to the functionality in the library in a platform independent way. To use it, is necessary to pass as argument to the constructor the path to the library. Then load it and resolve the desired functions. If no errors are found, the functions can be used as usual. Finally unload the library when it is not needed any more. See Listing \ref{lis:qlibrary}.


\begin{lstlisting}[style=customc, float=htb, caption={Qlibrary basic usage}, label = {lis:qlibrary}]

/***** In header file *****/
//Main zxcvbn function type
typedef double (*ZxcvbnMatch_type)(const char *Passwd, 
                                   const char *UserDict[], 
                                   ZxcMatch_t **Info );
//Function used to free the Info structure
typedef void (*ZxcvbnFreeInfo_type)(ZxcMatch_t *Info);

QLibrary * zxcvbnLib = 0;
ZxcvbnMatch_type ZxcvbnMatch = 0;
ZxcvbnFreeInfo_type ZxcvbnFreeInfo = 0;

/***** In cpp file *****/     
zxcvbnLib = new QLibrary(zxcvbn_lib_path);
    
if(zxcvbnLib->load()){
  ZxcvbnMatch = (ZxcvbnMatch_type) zxcvbnLib->resolve("ZxcvbnMatch");
  ZxcvbnFreeInfo =(ZxcvbnFreeInfo_type) zxcvbnLib->resolve("ZxcvbnFreeInfo");
}

if (!ZxcvbnMatch || !ZxcvbnFreeInfo ){
  //error: Any of the two functions was not resolved correctly
else{
  //we can use the functions normally
  
//When not needed any more
zxcvbnLib->unload();
ZxcvbnMatch = 0;
ZxcvbnFreeInfo = 0;
free(zxcvbnLib);  
  
\end{lstlisting}


\subsubsection*{User Dictionaries}

The user dictionary contain words that are relevant only to a specific user. For example, if the application is used to increase the strength level of passwords used by employees in a company, adding the company's name to the dictionary is a good idea. Furthermore, if the company works in the automotive business, related words as motor, aerodynamic, wheels etc. should be added. By adding those words to the user dictionary, the strength level of passwords using them will decrease, and so the user will be encouraged to never use words that are too easy to guess. The key to a good password is in its randomness. When a hacker is trying to crack one, they will for sure try words relevant to the target.

From the GUI the user can add words manually, or can load them from a text file, but as the words are saved as a simple array, the text file size should not be too large. For large files, it is better to add them as General dictionaries.

\subsubsection*{Estimator Usage}

After the library is loaded and the functions resolved, to use the estimator one simply needs to call the main function \texttt{ZxcvbnMatch} whose declaration we see in Listing \ref{lis:zxcvbn} 

\begin{lstlisting}[style=customc, float=htb, caption={ZxcvbnMatch function declaration}, label = {lis:zxcvbn}]
double ZxcvbnMatch(       //Returns: entropy value in bits.
 
  const char *Passwd,     //The password to be tested. Null terminated string. 
  
  const char *UserDict[], //User supplied dictionary words to be considered particulary bad. Passed as a pointer to array of string pointers, with null last entry (like the argv parameter to main()). May be null or point to empty array when there are no user dictionary words. 
  
  ZxcMatch_t **Info       //The address of a pointer variable to receive information on the parts of the password. This parameter can be null if no information is wanted. The data should be freed by calling ZxcvbnFreeInfo().
);
\end{lstlisting}

To obtain the password strength level, it is necessary to compare the \texttt{zxcvbnMatch} return value (The entropy in bits) as seen in section \ref{sec:zxLevels}. The strength level is shown to the user with a progress bar.
%TODO
\todo{talk about models and table}
To the user may be more relevant to see some estimates about how long it would take for an attacker to crack the password. This information can be obtained from the entropy, assuming some numbers for the attempts/time the attacker can perform. These results are shown in a table like the one in figure \ref{fig:zxcvbnTimes}
\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=1\columnwidth]{chapters/figures/development/zxcvbnTimes}
  \caption{Crack times for different attacker capabilities}
  \label{fig:zxcvbnTimes}
\end{figure}

Some interesting additional information can be obtained from \texttt{ZxcMatch\_t ** Info}. By traversing the data in this pointer, it is possible to see how the zxcvbn algorithm broke down the password. The user can see this information in a table like the one in figure \ref{fig:zxcvbnBreak}
\begin{figure}[htb]    
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.9\columnwidth]{chapters/figures/development/zxcvbnBreak}
  \caption{Password broke down by the zxcvbn algorithm}
  \label{fig:zxcvbnBreak}
\end{figure}



\subsection{PassPhrase Generator}

The \texttt{PassPhraseGen} C++ function implements the PassPhrase Generator. The function call is done from the \texttt{AddEntry} class, when the \texttt{Generate Password} button is clicked.

\texttt{AddEntry} reads the configuration values stored as \texttt{QSettings}, asserts them and then makes the call. This values can be modified by the user in the preferences window, shown in figure \ref{fig:ppgenSett}. After the user selects the dictionaries and tunes the available options, they must click the apply button, which will trigger a line by line read of the dictionaries, to count the number of lines, that is the number of words available. This is necessary as it is not possible to know how many lines a file has without counting them, and the total number is required in order to generate properly bounded random numbers in the PassPhraseGen function.

\begin{figure}[htb]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.8\columnwidth]{chapters/figures/development/ppgenSett.png}
  \caption{Settings for PassPhrase Generator}
  \label{fig:ppgenSett}
\end{figure}

The function declaration is shown in listings \ref{lis:ppgen}


\begin{lstlisting}[style=customc, float=htb, caption={PassPhraseGen function declaration}, label = {lis:ppgen}]
QString PassPhraseGen(  //Return: Generated PassPhrase
  QString path,         //path to dicts
  QStringList dicts,    //list of dicts
  QStringList dictsLen, //cumulative list of dics lengths
  int totalLen,         //total number of candidate words
  int numWords,         //number of words in the password
  bool ppgenMinLenEnab, //use only words longer than min len
  int ppgenMinLen,      //min length
  bool capFirst,        //uppercase first letter of each word
  bool ppgenLowerEnab,  //use only lower part of dicts
  int ppgenLower        //how much of the lower part to use
);
\end{lstlisting}

The function first generates \texttt{numWords} random numbers in the range \texttt{[1, totalLen]} with the Qt function \texttt{QRandomGenerator} (introduced in version 5.10). The generated numbers represent \textsl{Line numbers} in the dictionary files. As each line contains a word, the function indeed extracts random words. There are a few things to consider in this process:
\begin{enumerate}
\setlength\itemsep{0pt}
\item It is impossible to read a random line from a TextFile without reading all the previous lines first. So, in order to extract the words it is necessary to read the dictionary line by line and keep a counter to know the number line we are at. To speed up the process making sure each line is read only once, the random numbers are sorted in ascending order first. The dictionary can then be read line by line extracting the words where the counter equals one of the random numbers. When the last random line is extracted, the file can be closed.

\item There can be multiple dictionaries. The generated random numbers span the total of available words, so some random lines will be in some dictionaries, some in others. Therefore, using the \texttt{dictsLen} list, which contains the cumulative lengths of the dictionaries, we need to determine in which dictionary and in which internal line, each random number is. With this information, and the random numbers ordered, it is possible to extract the words efficiently and making sure dictionary files are opened only if necessary and only once.

\item When the minimum length option is enabled, the total number of available words is reduced. The algorithm accounts for this fact by counting only the lines with a word larger than the minimum length. This is done both in the preference window, where the total number of lines is counted, and at the word extraction process. In this way, the random lines are pinpointed as before, by reading line by line and comparing the counter; the working logic is not altered, it just ignores the "disabled" short lines.

\item Finally, to consider only the lower part of each dictionary the preferences window counting process is not altered, and the modifications are all done at the extraction process. If for example, the user wants to work with the lower 30\%, the random generated numbers are now bounded to \texttt{[1,  (0.3)totalLen]}. The corresponding dictionary and internal line for each random number are calculated by taking into account that the first 70\% of each dictionary must be skipped. With this two values, the files can be read as in the simple case. As this process is different from the minimum length one, they do not interfere with each other.

\end{enumerate}

Table \ref{tab:ppgenExm} presents some PassPhrases examples for different configurations, along side the score given by the zxcvbn estimator. The estimator uses the same dictionaries as the generator, so this assumes a worst case scenario where the hacker has access to all the possible words the user considered when creating the PassPhrase.

Two dictionaries where used: \texttt{words-eng\_wiki.txt} with 100000 lines and \texttt{words-it\_badip.txt} with 15480 lines (around 6 times smaller), so most of the extracted words will be English.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{PassPhrases examples for different configurations}
\begin{tabular*}{\columnwidth}{
@{\extracolsep{\fill}}
m{6.5cm}ccccc
@{}}
\toprule
\hd{PassPhrase} & \hd{No. of \\ words} & \hd{Min.\\word \\ Len} & \hd{\% of \\ dict.\\ used } &\hd{Log \\ Entropy \\ \& Level}\\ \midrule

		 Cocchio & 1 & - & - & 4.27 (L1) \\ 
		 Melun   & 1 & - & - & 4.93 (L1) \\ 
		 
		 Legitimately & 1 & 8 & - & 4.55 (L1) \\
     
     Woodhaven		& 1 & 8 & 30\% & 4.94 (L1) \\
     \midrule
     VestaOrman    & 2 & - & - & 7.78 (L2) \\    
     ShorelineCech & 2 & - & - & 9.18 (L3) \\
     
     MongoliaSimpsons & 2 & 8 & -    & 7.30 (L2) \\
     McinnisPhaya     & 2 & - & 30\% & 9.14 (L3) \\

     ZucchiniSalamandra & 2 & 8 & 30\% & 9.19 (L3) \\
     SacchettiVigevano  & 2 & 8 & 30\% & 9.11 (L3) \\

     DrammaturgicoSbatacchiare  & 2 & 12 & - & 8.98 (L3) \\
     MalformationsAstrophysical & 2 & 12 & - & 9.60 (L3) \\
     \midrule
     LatinaInterchangeFbo & 3 & - & - & 13.5  (L4) \\
     OsaAymanCantinflas   & 3 & - & - & 12.98 (L4) \\
     ImmobileCwSites      & 3 & - & - & 11.43 (L4) \\
     
     RimmelBragFaenza     & 3 & - & 30\% & 13.491 (L4) \\
     
     RecliningCanberraEcuadorian         & 3 & 8 &  -   & 13.69 (L4) \\
     
     
     SeashellsHippocraticCameroun        & 3 & 8 & 30\% & 14.90 (L4) \\
     InaspettatoRothschildsDisconcerting & 3 & 8 & 30\% & 14.48 (L4) \\
\bottomrule
\end{tabular*}
		\label{tab:ppgenExm}
\end{table}

The results in the table indicate the most important parameter is the number of words. Three words are enough to reach a zxcvbn level 4, which, as seen in previous sections, is very secure. A two word PassPhrase as long as \texttt{DrammaturgicoSbatacchiare} is not better than the shorter \texttt{ImmobileCwSites}, because the latter has one more word. The minimum word length also influences the PassPhrase entropy, but their effects are not as pronounced. Finally, working only with to the lower part of the dictionary may seem to not have any effect, but in reality its use is crucial: it ensures the generated PassPhrases do not contain any of the most common words, like \texttt{the} or \texttt{essere}. From the results on the table we can not appreciate this fact, but at least we learn the option does not do any harm either. (Although if the attacker finds out the user is generating PassPhrases using only the 30\% most uncommon words on a given language, they job would get easier).













